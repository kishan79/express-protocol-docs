{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Express Protocol! Express protocol is a decentralized protocol built on top of blockchain layer which aims at bringing/ balancing liquidity in the NFT Marketplaces created using the Protocol's SDK. Our protocol backs developer of all kinds, from standard software developer (web2) to blockchain developers (web3), from solo programmers to a professional scaled team and everything in between. Get Started To directly walk through the process of installation and initialization of Express Protocol SDK, get started with Installation . Protocol Overview The Express Protocol encapsulates a combination of Smart Contracts and Libraries, as well as a Software Development Kit, built over them. The Smart Contracts interact directly with the blockchains(multiple supported). Protocol Smart Contracts These smart contracts have functionalities to mint, trade and auction tokens of ERC721 and ERC1155 Standards. The SDK built on top of the Smart Contracts enable clients to use the Protocol's Smart Contracts functionalities without directly interacting with the blockchain and smart contracts. Protocol SDK","title":"Overview"},{"location":"#welcome-to-express-protocol","text":"Express protocol is a decentralized protocol built on top of blockchain layer which aims at bringing/ balancing liquidity in the NFT Marketplaces created using the Protocol's SDK. Our protocol backs developer of all kinds, from standard software developer (web2) to blockchain developers (web3), from solo programmers to a professional scaled team and everything in between.","title":"Welcome to Express Protocol!"},{"location":"#get-started","text":"To directly walk through the process of installation and initialization of Express Protocol SDK, get started with Installation .","title":"Get Started"},{"location":"#protocol-overview","text":"The Express Protocol encapsulates a combination of Smart Contracts and Libraries, as well as a Software Development Kit, built over them. The Smart Contracts interact directly with the blockchains(multiple supported). Protocol Smart Contracts These smart contracts have functionalities to mint, trade and auction tokens of ERC721 and ERC1155 Standards. The SDK built on top of the Smart Contracts enable clients to use the Protocol's Smart Contracts functionalities without directly interacting with the blockchain and smart contracts. Protocol SDK","title":"Protocol Overview"},{"location":"express/","text":"Through Express Protocol's robust and handy SDK, you can develop from a simple NFT minting dApp to a complex multistandard multichain NFT Marketplace with features like auctioning, creating collections and much more. Challanges with developing NFT dApps Nativity: Developers need to be native to the web3 tech, have good familiarity with blockchain and must be proficient in writing smart contracts. Ease of Use: Developing dApps involves checking many marks like writing efficient functions, adding modifiers and decorators, controlling access and a hell lot. Time Consumption: Checking above mentioned marks and writing smart contracts from scratch takes a good amount of time. Security: With transfering assets and funds through dApps, there comes many vulnerabilities which can and had caused exploitation of funds and complete failure of application in past. How Express Protocol Solves these challenge Express SDK enables developer to create NFT dApps without gettting intimidated by blockchain and smart contract complexities. SDK takes care of interacting at blockchain level and developer just need to design a frontend, set up a wallet and call SDK function to create a operating NFT dApp. With Express SDK, developers don't have to write smart contracts from scratch for their dApp, so they can put their skills and energy in creating innovative and out of the box applications instead of re-inventing the wheel. Building NFT Marketplaces may take days and weeks but with Express SDK, it is possible to build fully functional multinetwork NFT Marketplace in few hours. Express Protocol codebase is open source and the Protocol's Smart Contracts have gone through multiple phase of auditing and hence it ensures that building dApps with Express SDK, which is built on well tested Smart Contracts, is immune to all the existing threats and vulnerabilities. These are plenty of challenges Express Protocol is solving, but the centre of attention is yet to come . Liquidating Assets Currently, the major problem with the NFT Marketplaces is the lack of liquidity or unbalanced liquidity among markets. There are many scenarios where there is a NFT listed on one marketplace but the potential bidders and buyers are unaware about the listing as they might be on any other marketplace and hence the order stays unfilled. Express protocol liquidates assets through the concept of shared order book. Every marketplaces built using Express SDK shares all the listing and placed orders and therefore balancing liquidity among markets. This simply means that a NFT listed on one market place can be filled through all other markets built using our SDK.","title":"Why Express?"},{"location":"express/#challanges-with-developing-nft-dapps","text":"Nativity: Developers need to be native to the web3 tech, have good familiarity with blockchain and must be proficient in writing smart contracts. Ease of Use: Developing dApps involves checking many marks like writing efficient functions, adding modifiers and decorators, controlling access and a hell lot. Time Consumption: Checking above mentioned marks and writing smart contracts from scratch takes a good amount of time. Security: With transfering assets and funds through dApps, there comes many vulnerabilities which can and had caused exploitation of funds and complete failure of application in past.","title":"Challanges with developing NFT dApps"},{"location":"express/#how-express-protocol-solves-these-challenge","text":"Express SDK enables developer to create NFT dApps without gettting intimidated by blockchain and smart contract complexities. SDK takes care of interacting at blockchain level and developer just need to design a frontend, set up a wallet and call SDK function to create a operating NFT dApp. With Express SDK, developers don't have to write smart contracts from scratch for their dApp, so they can put their skills and energy in creating innovative and out of the box applications instead of re-inventing the wheel. Building NFT Marketplaces may take days and weeks but with Express SDK, it is possible to build fully functional multinetwork NFT Marketplace in few hours. Express Protocol codebase is open source and the Protocol's Smart Contracts have gone through multiple phase of auditing and hence it ensures that building dApps with Express SDK, which is built on well tested Smart Contracts, is immune to all the existing threats and vulnerabilities. These are plenty of challenges Express Protocol is solving, but the centre of attention is yet to come .","title":"How Express Protocol Solves these challenge"},{"location":"express/#liquidating-assets","text":"Currently, the major problem with the NFT Marketplaces is the lack of liquidity or unbalanced liquidity among markets. There are many scenarios where there is a NFT listed on one marketplace but the potential bidders and buyers are unaware about the listing as they might be on any other marketplace and hence the order stays unfilled. Express protocol liquidates assets through the concept of shared order book. Every marketplaces built using Express SDK shares all the listing and placed orders and therefore balancing liquidity among markets. This simply means that a NFT listed on one market place can be filled through all other markets built using our SDK.","title":"Liquidating Assets"},{"location":"guide/","text":"Create NFT Marketplace using Pandora-express SDK Intro In this guide we will make NFT marketplace Dapp using Express Protocol SDK through which anyone can mint, buy and sell tokens. We will use Pandora Public ERC721 contract for NFT minting and Pandora Market Contract for Buying/Selling NFTs. You also need to connect a wallet, so make sure you have metamask wallet installed. Alright without further ado, let's create our marketplace! Prerequisites Some Prequisites required before building the project: NodeJS version > 16.0.0 NPM version > 6.0.0 Metamask Browser Extension Parcel Bundler(For bundling Javascript) Code 1.Creating Project: Create an empty folder in your favourite editor. We will use VScode here. 2.SDK installation Run in terminal npm init npm i pandora-express npm install -g parcel-bundler 3.Building the UI Make a index.html file and paste the following code. Here we will make three input fields, User have to enter the tokenURI in the first field that will create an NFT for that user. Next section will take token's ID that the user have created previously and the base price in which the user want to sell his NFT, this will put the NFT on sale. Followed by the last section in which the the NFT buyer can buy the NFT by providing the Sale ID of the NFT and the amount he want to offer. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > SDK </ title > </ head > < body > < div id = \"createItem\" > < h4 > Create Item </ h4 > < input type = \"text\" id = \"txtCreateItemURI\" required placeholder = \"Enter TokenURI\" /> < button id = \"btnCreateItem\" > Create Item </ button > </ div > < div id = \"sellItem\" > < h4 > Sell Item </ h4 > < input type = \"number\" min = \"1\" step = \"1\" id = \"numSellItemTokenId\" placeholder = \"Enter TokenId\" required /> < input type = \"number\" min = \"1\" step = \"1\" id = \"numSellItemPrice\" placeholder = \"Enter Price\" required /> < button id = \"btnSellItem\" > Sell Item </ button > </ div > < div id = \"buyItem\" > < h4 > Buy Item </ h4 > < input type = \"number\" min = \"1\" step = \"1\" id = \"numBuyItem\" placeholder = \"Enter SaleId\" required /> < input type = \"number\" min = \"1\" step = \"1\" id = \"numBuyItemAmmount\" placeholder = \"Enter Ammount\" required /> < button id = \"btnBuyItem\" > Buy Item </ button > </ div > < script src = \"https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\" ></ script > < script src = \"main.js\" ></ script > </ body > </ html > Now run the app with live server. As we have pasted the code, now our frontend will look something like this: 4.Using SDK code with our javascript Logic Make a Javascript file, name it main.js, Now we have to import SDK function in our Dapp and make connection with blockchain using metamask. Paste the code below in main.js file. //Import createPandoraExpressSDK from SDK const { createPandoraExpressSDK } = require ( \"pandora-express\" ); const pandoraSDK = createPandoraExpressSDK (); //Connecting with Metamask wallet. const init = async () => { //check if metamask is present if ( window . ethereum ) { window . web3 = new Web3 ( window . ethereum ); await window . ethereum . enable (); console . log ( \"Connected\" ); } else { alert ( \"Metamask not found\" ); } }; Now, we have to define the Mint function, that will mint NFT using the SDK. const mintNft = async () => { //get current account address const accounts = await web3 . eth . getAccounts (); //Get ChainID of current account const chainId = await web3 . eth . net . getId (); //Mint NFT using SDK erc721 nft mint await pandoraSDK . erc721 . nft . mint ( web3 , chainId , accounts [ 0 ], itemURI . value , [ [ accounts [ 0 ], 100 ], ]); }; We have minted a NFT using the SDK now, we can sell the NFT in the market using Sell function of the SDK. Define the Sell NFT function as written below. const sellNft = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . order . sellNFT ( web3 , chainId , sellItemTokenId . value , sellItemPrice . value , accounts [ 0 ] ); }; We have put an NFT on sale, anyone else can buy the NFT by providing Price more than the sellItemPrice. You can also try buying the same NFT using different account in your metamask wallet. Try pasting the code below for buying NFT. const buyNft = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . order . buyNFT ( web3 , chainId , buyItemSaleId . value , accounts [ 0 ], buyItemAmmount . value ); }; 5.Getting Data from User from Frontend Now as we defined the functions for our NFT marketplace, the last step is to get the function parameters using javascript DOM. Paste the code written below to main.js. const itemURI = document . getElementById ( \"txtCreateItemURI\" ); const createItemButton = document . getElementById ( \"btnCreateItem\" ); createItemButton . onclick = mintNft ; const sellItemTokenId = document . getElementById ( \"numSellItemTokenId\" ); const sellItemPrice = document . getElementById ( \"numSellItemPrice\" ); const sellItemButton = document . getElementById ( \"btnSellItem\" ); sellItemButton . onclick = sellNft ; const buyItemSaleId = document . getElementById ( \"numBuyItem\" ); const buyItemAmmount = document . getElementById ( \"numBuyItemAmmount\" ); numBuyItemAmmount ; const buyItemButton = document . getElementById ( \"btnBuyItem\" ); buyItemButton . onclick = buyNft ; init (); Now run in terminal parcel index.html That's it! Congratulations! You have created your own marketplace and minted as well as listed your first Token in the Marketplace ! If you want to use this functionality and numerous others like timed auction, creating collection, bidding, etc today in your app, check out the Express SDK section which gives you a plug and play SDK component for front end.","title":"NFT MarketPlace"},{"location":"guide/#create-nft-marketplace-using-pandora-express-sdk","text":"","title":"Create NFT Marketplace using Pandora-express SDK"},{"location":"guide/#intro","text":"In this guide we will make NFT marketplace Dapp using Express Protocol SDK through which anyone can mint, buy and sell tokens. We will use Pandora Public ERC721 contract for NFT minting and Pandora Market Contract for Buying/Selling NFTs. You also need to connect a wallet, so make sure you have metamask wallet installed. Alright without further ado, let's create our marketplace!","title":"Intro"},{"location":"guide/#prerequisites","text":"","title":"Prerequisites"},{"location":"guide/#some-prequisites-required-before-building-the-project","text":"NodeJS version > 16.0.0 NPM version > 6.0.0 Metamask Browser Extension Parcel Bundler(For bundling Javascript)","title":"Some Prequisites required before building the project:"},{"location":"guide/#code","text":"1.Creating Project: Create an empty folder in your favourite editor. We will use VScode here. 2.SDK installation Run in terminal npm init npm i pandora-express npm install -g parcel-bundler 3.Building the UI Make a index.html file and paste the following code. Here we will make three input fields, User have to enter the tokenURI in the first field that will create an NFT for that user. Next section will take token's ID that the user have created previously and the base price in which the user want to sell his NFT, this will put the NFT on sale. Followed by the last section in which the the NFT buyer can buy the NFT by providing the Sale ID of the NFT and the amount he want to offer. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > SDK </ title > </ head > < body > < div id = \"createItem\" > < h4 > Create Item </ h4 > < input type = \"text\" id = \"txtCreateItemURI\" required placeholder = \"Enter TokenURI\" /> < button id = \"btnCreateItem\" > Create Item </ button > </ div > < div id = \"sellItem\" > < h4 > Sell Item </ h4 > < input type = \"number\" min = \"1\" step = \"1\" id = \"numSellItemTokenId\" placeholder = \"Enter TokenId\" required /> < input type = \"number\" min = \"1\" step = \"1\" id = \"numSellItemPrice\" placeholder = \"Enter Price\" required /> < button id = \"btnSellItem\" > Sell Item </ button > </ div > < div id = \"buyItem\" > < h4 > Buy Item </ h4 > < input type = \"number\" min = \"1\" step = \"1\" id = \"numBuyItem\" placeholder = \"Enter SaleId\" required /> < input type = \"number\" min = \"1\" step = \"1\" id = \"numBuyItemAmmount\" placeholder = \"Enter Ammount\" required /> < button id = \"btnBuyItem\" > Buy Item </ button > </ div > < script src = \"https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\" ></ script > < script src = \"main.js\" ></ script > </ body > </ html > Now run the app with live server. As we have pasted the code, now our frontend will look something like this: 4.Using SDK code with our javascript Logic Make a Javascript file, name it main.js, Now we have to import SDK function in our Dapp and make connection with blockchain using metamask. Paste the code below in main.js file. //Import createPandoraExpressSDK from SDK const { createPandoraExpressSDK } = require ( \"pandora-express\" ); const pandoraSDK = createPandoraExpressSDK (); //Connecting with Metamask wallet. const init = async () => { //check if metamask is present if ( window . ethereum ) { window . web3 = new Web3 ( window . ethereum ); await window . ethereum . enable (); console . log ( \"Connected\" ); } else { alert ( \"Metamask not found\" ); } }; Now, we have to define the Mint function, that will mint NFT using the SDK. const mintNft = async () => { //get current account address const accounts = await web3 . eth . getAccounts (); //Get ChainID of current account const chainId = await web3 . eth . net . getId (); //Mint NFT using SDK erc721 nft mint await pandoraSDK . erc721 . nft . mint ( web3 , chainId , accounts [ 0 ], itemURI . value , [ [ accounts [ 0 ], 100 ], ]); }; We have minted a NFT using the SDK now, we can sell the NFT in the market using Sell function of the SDK. Define the Sell NFT function as written below. const sellNft = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . order . sellNFT ( web3 , chainId , sellItemTokenId . value , sellItemPrice . value , accounts [ 0 ] ); }; We have put an NFT on sale, anyone else can buy the NFT by providing Price more than the sellItemPrice. You can also try buying the same NFT using different account in your metamask wallet. Try pasting the code below for buying NFT. const buyNft = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . order . buyNFT ( web3 , chainId , buyItemSaleId . value , accounts [ 0 ], buyItemAmmount . value ); }; 5.Getting Data from User from Frontend Now as we defined the functions for our NFT marketplace, the last step is to get the function parameters using javascript DOM. Paste the code written below to main.js. const itemURI = document . getElementById ( \"txtCreateItemURI\" ); const createItemButton = document . getElementById ( \"btnCreateItem\" ); createItemButton . onclick = mintNft ; const sellItemTokenId = document . getElementById ( \"numSellItemTokenId\" ); const sellItemPrice = document . getElementById ( \"numSellItemPrice\" ); const sellItemButton = document . getElementById ( \"btnSellItem\" ); sellItemButton . onclick = sellNft ; const buyItemSaleId = document . getElementById ( \"numBuyItem\" ); const buyItemAmmount = document . getElementById ( \"numBuyItemAmmount\" ); numBuyItemAmmount ; const buyItemButton = document . getElementById ( \"btnBuyItem\" ); buyItemButton . onclick = buyNft ; init (); Now run in terminal parcel index.html That's it! Congratulations! You have created your own marketplace and minted as well as listed your first Token in the Marketplace ! If you want to use this functionality and numerous others like timed auction, creating collection, bidding, etc today in your app, check out the Express SDK section which gives you a plug and play SDK component for front end.","title":"Code"},{"location":"guide1/","text":"Create NFT Auctions using Pandora-express SDK Intro In this guide we will make NFT marketplace Dapp using Express Protocol SDK through which anyone can Mint NFTs, Auction them and buyers can Bid on tokens. We will use Pandora Public ERC721 contract for NFT minting and Pandora Market Contract for Auctioning/Bidding of NFTs. You also need to connect a wallet, so make sure you have metamask wallet installed. Alright without further ado, let's create our marketplace! Prerequisites Some Prequisites required before building the project: NodeJS version > 16.0.0 NPM version > 6.0.0 Metamask Browser Extension Parcel Bundler(For bundling Javascript) Code 1.Creating Project: Create an empty folder in your favourite editor. We will use VScode here. 2.SDK installation Run in terminal npm init npm i pandora-express npm install -g parcel-bundler 3.Building the UI Make a index.html file and paste the following code. Here we have made five sections for the frontend, first one we have the create item section, in which any user can mint NFT. Then we have auction section in which user can put their NFT on auction, it has three fields, one for token ID, one for setting Base price of NFT and next for time span in which the auction will end. Then we have next section for user who want to Bid on the auctioned NFT, user have to enter the sale ID and the Bid offer he want to make for the NFT. Next we have execute Bid section through which the NFT owner can accept the bid made by the bidders, we have two fields for the Sale ID and Bid ID. Next their is withdraw bid section, by which bidders can withdraw the bid they have made, bidders have to pass the sale ID and Bid ID in the fields present. At last their is the cancel sale section, NFT owner can cancel the auction of their NFT. User have to enter only the Sale ID. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > SDK </ title > </ head > < body > < div id = \"createItem\" > < h4 > Create Item </ h4 > < input type = \"text\" id = \"txtCreateItemURI\" required placeholder = \"Enter TokenURI\" /> < button id = \"btnCreateItem\" > Create Item </ button > </ div > < div id = \"auctionItem\" > < h4 > Auction Item </ h4 > < input type = \"number\" min = \"1\" step = \"1\" id = \"numAuctionItemTokenId\" placeholder = \"Enter TokenId\" required /> < input type = \"number\" min = \"1\" step = \"1\" id = \"numAuctionItemPrice\" placeholder = \"Enter Auction Price\" required /> < input type = \"number\" min = \"1\" step = \"1\" id = \"numAuctionItemTime\" placeholder = \"Enter Auction Time\" required /> < button id = \"btnAuctionItem\" > Auction Item </ button > </ div > < div id = \"Bid\" > < h4 > Bid </ h4 > < input type = \"number\" id = \"numBidItemSaleId\" required placeholder = \"Enter SaleId\" /> < input type = \"number\" id = \"numBidItemPrice\" required placeholder = \"Enter Bid Price\" /> < button id = \"btnBidItem\" > Bid </ button > </ div > < div id = \"executeBid\" > < h4 > Execute Bid </ h4 > < input type = \"number\" id = \"numExecuteSaleId\" required placeholder = \"Enter SaleId\" /> < input type = \"number\" id = \"numExecuteBidId\" required placeholder = \"Enter BidId\" /> < button id = \"btnExecuteBidItem\" > Execute Bid </ button > </ div > < div id = \"withdrawBid\" > < h4 > Withdraw Bid Money </ h4 > < input type = \"number\" id = \"numWithdrawSaleId\" required placeholder = \"Enter SaleId\" /> < input type = \"number\" id = \"numWithdrawBidId\" required placeholder = \"Enter BidId\" /> < button id = \"btnWithdrawBidItem\" > Withdraw Bid </ button > </ div > < div id = \"withdrawBid\" > < h4 > Cancel Item Sale </ h4 > < input type = \"number\" id = \"numCancelSaleId\" required placeholder = \"Enter SaleId\" /> < button id = \"btnCancelItemSale\" > Cancel Sale </ button > </ div > < script src = \"https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\" ></ script > < script src = \"main.js\" ></ script > </ body > </ html > Now run the app with live server As we have pasted the code, Now our frontend will look something like this: 4.Using SDK code with our javascript Logic Make a Javascript file, name it main.js, Now we have to import SDK function in our Dapp and make connection with blockchain using metamask. Paste the code below in main.js file. //Import createPandoraExpressSDK from SDK const { createPandoraExpressSDK } = require ( \"pandora-express\" ); const pandoraSDK = createPandoraExpressSDK (); //Connecting with Metamask wallet. const init = async () => { //check if metamask is present if ( window . ethereum ) { window . web3 = new Web3 ( window . ethereum ); await window . ethereum . enable (); console . log ( \"Connected\" ); } else { alert ( \"Metamask not found\" ); } }; Now, we have to define the Mint function, that will mint NFT using the SDK. const mintNft = async () => { //get current account address const accounts = await web3 . eth . getAccounts (); //Get ChainID of current account const chainId = await web3 . eth . net . getId (); //Mint NFT using SDK erc721 nft mint await pandoraSDK . erc721 . nft . mint ( web3 , chainId , accounts [ 0 ], itemURI . value , [ [ accounts [ 0 ], 100 ], ]); } We have minted a NFT using the SDK now, we can put the NFT in auction using sellNFTByBid function of the SDK. Define the auction NFT function that will call the PandoraSDK.erc721.order.sellNFTByBid function. const auctionNft = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . order . sellNFTByBid ( web3 , chainId , auctionItemTokenId . value , //Token ID auctionItemPrice . value , // Base Price of Token accounts [ 0 ], auctionItemTime . value // Time of Auction ); } After putting the item on Auction, anyone can Bid on the Token by providing price more than the base price of the Token or price more than the previous highest Bid. We can implement the Bid function in our App using the PandoraSDK.erc721.order.bid function. const bid = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . order . bid ( web3 , chainId , BidItemSaleId . value , //Sale ID of Token accounts [ 0 ], BidItemPrice . value // Price offered by the Bidder ); }; The owner of the Token can accept the Bid that he likes using the PandoraSDK.erc721.order.acceptBid function. Lets define a function that owner of Token will use to accept the offer. const executeBid = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . order . acceptBid ( web3 , chainId , ExecuteSaleId . value , //Sale ID of the token on Auction ExecuteBidId . value , //Bid ID of the Bid offering accounts [ 0 ] ); }; After Auction is over and if the Bidder's bid is not accepted then they can withdraw their bids. We will use pandoraSDK.erc721.order.withdrawBid() function to implement this. const withdrawBidMoney = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . order . withdrawBid ( web3 , chainId , WithdrawSaleId . value , WithdrawBidId . value , accounts [ 0 ] ); } The Owner of the token can cancel the auction using the pandoraSDK.erc721.order.cancelSale() function. Lets define the function for our app. const cancelSale = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . order . cancelSale ( web3 , chainId , accounts [ 0 ], CancelSaleId . value ); } 5.Getting Data from User from Frontend Now as we defined the functions for our Dapp, the last step is to get the function parameters using javascript DOM. Paste the code written below to main.js. const itemURI = document . getElementById ( \"txtCreateItemURI\" ); const createItemButton = document . getElementById ( \"btnCreateItem\" ); createItemButton . onclick = mintNft ; const itemURI1 = document . getElementById ( \"txtCreateItemURI1\" ); const itemURI2 = document . getElementById ( \"txtCreateItemURI2\" ); const auctionItemTokenId = document . getElementById ( \"numAuctionItemTokenId\" ); const auctionItemPrice = document . getElementById ( \"numAuctionItemPrice\" ); const auctionItemTime = document . getElementById ( \"numAuctionItemTime\" ); const auctionItemButton = document . getElementById ( \"btnAuctionItem\" ); auctionItemButton . onclick = auctionNft ; const BidItemSaleId = document . getElementById ( \"numBidItemSaleId\" ); const BidItemPrice = document . getElementById ( \"numBidItemPrice\" ); const BidItemButton = document . getElementById ( \"btnBidItem\" ); BidItemButton . onclick = bid ; const ExecuteSaleId = document . getElementById ( \"numExecuteSaleId\" ); const ExecuteBidId = document . getElementById ( \"numExecuteBidId\" ); const ExecuteBidItemButton = document . getElementById ( \"btnExecuteBidItem\" ); ExecuteBidItemButton . onclick = executeBid ; const WithdrawSaleId = document . getElementById ( \"numWithdrawSaleId\" ); const WithdrawBidId = document . getElementById ( \"numWithdrawBidId\" ); const WithdrawBidItemButton = document . getElementById ( \"btnWithdrawBidItem\" ); WithdrawBidItemButton . onclick = withdrawBidMoney ; const CancelSaleId = document . getElementById ( \"numCancelSaleId\" ); const CancelItemSaleButton = document . getElementById ( \"btnCancelItemSale\" ); CancelItemSaleButton . onclick = cancelSale ; init (); Now run in terminal parcel index.html All Set! Congratulations! You have created your own NFT trading marketplace and minted as well as listed your first Token in the Marketplace ! If you want to use this functionality and numerous others things like timed auction, creating collection, bidding, etc today in your app, check out the Express SDK section which gives you a plug and play SDK component for front end.","title":"NFT Auction Market"},{"location":"guide1/#create-nft-auctions-using-pandora-express-sdk","text":"","title":"Create NFT Auctions using Pandora-express SDK"},{"location":"guide1/#intro","text":"In this guide we will make NFT marketplace Dapp using Express Protocol SDK through which anyone can Mint NFTs, Auction them and buyers can Bid on tokens. We will use Pandora Public ERC721 contract for NFT minting and Pandora Market Contract for Auctioning/Bidding of NFTs. You also need to connect a wallet, so make sure you have metamask wallet installed. Alright without further ado, let's create our marketplace!","title":"Intro"},{"location":"guide1/#prerequisites","text":"","title":"Prerequisites"},{"location":"guide1/#some-prequisites-required-before-building-the-project","text":"NodeJS version > 16.0.0 NPM version > 6.0.0 Metamask Browser Extension Parcel Bundler(For bundling Javascript)","title":"Some Prequisites required before building the project:"},{"location":"guide1/#code","text":"1.Creating Project: Create an empty folder in your favourite editor. We will use VScode here. 2.SDK installation Run in terminal npm init npm i pandora-express npm install -g parcel-bundler 3.Building the UI Make a index.html file and paste the following code. Here we have made five sections for the frontend, first one we have the create item section, in which any user can mint NFT. Then we have auction section in which user can put their NFT on auction, it has three fields, one for token ID, one for setting Base price of NFT and next for time span in which the auction will end. Then we have next section for user who want to Bid on the auctioned NFT, user have to enter the sale ID and the Bid offer he want to make for the NFT. Next we have execute Bid section through which the NFT owner can accept the bid made by the bidders, we have two fields for the Sale ID and Bid ID. Next their is withdraw bid section, by which bidders can withdraw the bid they have made, bidders have to pass the sale ID and Bid ID in the fields present. At last their is the cancel sale section, NFT owner can cancel the auction of their NFT. User have to enter only the Sale ID. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > SDK </ title > </ head > < body > < div id = \"createItem\" > < h4 > Create Item </ h4 > < input type = \"text\" id = \"txtCreateItemURI\" required placeholder = \"Enter TokenURI\" /> < button id = \"btnCreateItem\" > Create Item </ button > </ div > < div id = \"auctionItem\" > < h4 > Auction Item </ h4 > < input type = \"number\" min = \"1\" step = \"1\" id = \"numAuctionItemTokenId\" placeholder = \"Enter TokenId\" required /> < input type = \"number\" min = \"1\" step = \"1\" id = \"numAuctionItemPrice\" placeholder = \"Enter Auction Price\" required /> < input type = \"number\" min = \"1\" step = \"1\" id = \"numAuctionItemTime\" placeholder = \"Enter Auction Time\" required /> < button id = \"btnAuctionItem\" > Auction Item </ button > </ div > < div id = \"Bid\" > < h4 > Bid </ h4 > < input type = \"number\" id = \"numBidItemSaleId\" required placeholder = \"Enter SaleId\" /> < input type = \"number\" id = \"numBidItemPrice\" required placeholder = \"Enter Bid Price\" /> < button id = \"btnBidItem\" > Bid </ button > </ div > < div id = \"executeBid\" > < h4 > Execute Bid </ h4 > < input type = \"number\" id = \"numExecuteSaleId\" required placeholder = \"Enter SaleId\" /> < input type = \"number\" id = \"numExecuteBidId\" required placeholder = \"Enter BidId\" /> < button id = \"btnExecuteBidItem\" > Execute Bid </ button > </ div > < div id = \"withdrawBid\" > < h4 > Withdraw Bid Money </ h4 > < input type = \"number\" id = \"numWithdrawSaleId\" required placeholder = \"Enter SaleId\" /> < input type = \"number\" id = \"numWithdrawBidId\" required placeholder = \"Enter BidId\" /> < button id = \"btnWithdrawBidItem\" > Withdraw Bid </ button > </ div > < div id = \"withdrawBid\" > < h4 > Cancel Item Sale </ h4 > < input type = \"number\" id = \"numCancelSaleId\" required placeholder = \"Enter SaleId\" /> < button id = \"btnCancelItemSale\" > Cancel Sale </ button > </ div > < script src = \"https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\" ></ script > < script src = \"main.js\" ></ script > </ body > </ html > Now run the app with live server As we have pasted the code, Now our frontend will look something like this: 4.Using SDK code with our javascript Logic Make a Javascript file, name it main.js, Now we have to import SDK function in our Dapp and make connection with blockchain using metamask. Paste the code below in main.js file. //Import createPandoraExpressSDK from SDK const { createPandoraExpressSDK } = require ( \"pandora-express\" ); const pandoraSDK = createPandoraExpressSDK (); //Connecting with Metamask wallet. const init = async () => { //check if metamask is present if ( window . ethereum ) { window . web3 = new Web3 ( window . ethereum ); await window . ethereum . enable (); console . log ( \"Connected\" ); } else { alert ( \"Metamask not found\" ); } }; Now, we have to define the Mint function, that will mint NFT using the SDK. const mintNft = async () => { //get current account address const accounts = await web3 . eth . getAccounts (); //Get ChainID of current account const chainId = await web3 . eth . net . getId (); //Mint NFT using SDK erc721 nft mint await pandoraSDK . erc721 . nft . mint ( web3 , chainId , accounts [ 0 ], itemURI . value , [ [ accounts [ 0 ], 100 ], ]); } We have minted a NFT using the SDK now, we can put the NFT in auction using sellNFTByBid function of the SDK. Define the auction NFT function that will call the PandoraSDK.erc721.order.sellNFTByBid function. const auctionNft = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . order . sellNFTByBid ( web3 , chainId , auctionItemTokenId . value , //Token ID auctionItemPrice . value , // Base Price of Token accounts [ 0 ], auctionItemTime . value // Time of Auction ); } After putting the item on Auction, anyone can Bid on the Token by providing price more than the base price of the Token or price more than the previous highest Bid. We can implement the Bid function in our App using the PandoraSDK.erc721.order.bid function. const bid = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . order . bid ( web3 , chainId , BidItemSaleId . value , //Sale ID of Token accounts [ 0 ], BidItemPrice . value // Price offered by the Bidder ); }; The owner of the Token can accept the Bid that he likes using the PandoraSDK.erc721.order.acceptBid function. Lets define a function that owner of Token will use to accept the offer. const executeBid = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . order . acceptBid ( web3 , chainId , ExecuteSaleId . value , //Sale ID of the token on Auction ExecuteBidId . value , //Bid ID of the Bid offering accounts [ 0 ] ); }; After Auction is over and if the Bidder's bid is not accepted then they can withdraw their bids. We will use pandoraSDK.erc721.order.withdrawBid() function to implement this. const withdrawBidMoney = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . order . withdrawBid ( web3 , chainId , WithdrawSaleId . value , WithdrawBidId . value , accounts [ 0 ] ); } The Owner of the token can cancel the auction using the pandoraSDK.erc721.order.cancelSale() function. Lets define the function for our app. const cancelSale = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . order . cancelSale ( web3 , chainId , accounts [ 0 ], CancelSaleId . value ); } 5.Getting Data from User from Frontend Now as we defined the functions for our Dapp, the last step is to get the function parameters using javascript DOM. Paste the code written below to main.js. const itemURI = document . getElementById ( \"txtCreateItemURI\" ); const createItemButton = document . getElementById ( \"btnCreateItem\" ); createItemButton . onclick = mintNft ; const itemURI1 = document . getElementById ( \"txtCreateItemURI1\" ); const itemURI2 = document . getElementById ( \"txtCreateItemURI2\" ); const auctionItemTokenId = document . getElementById ( \"numAuctionItemTokenId\" ); const auctionItemPrice = document . getElementById ( \"numAuctionItemPrice\" ); const auctionItemTime = document . getElementById ( \"numAuctionItemTime\" ); const auctionItemButton = document . getElementById ( \"btnAuctionItem\" ); auctionItemButton . onclick = auctionNft ; const BidItemSaleId = document . getElementById ( \"numBidItemSaleId\" ); const BidItemPrice = document . getElementById ( \"numBidItemPrice\" ); const BidItemButton = document . getElementById ( \"btnBidItem\" ); BidItemButton . onclick = bid ; const ExecuteSaleId = document . getElementById ( \"numExecuteSaleId\" ); const ExecuteBidId = document . getElementById ( \"numExecuteBidId\" ); const ExecuteBidItemButton = document . getElementById ( \"btnExecuteBidItem\" ); ExecuteBidItemButton . onclick = executeBid ; const WithdrawSaleId = document . getElementById ( \"numWithdrawSaleId\" ); const WithdrawBidId = document . getElementById ( \"numWithdrawBidId\" ); const WithdrawBidItemButton = document . getElementById ( \"btnWithdrawBidItem\" ); WithdrawBidItemButton . onclick = withdrawBidMoney ; const CancelSaleId = document . getElementById ( \"numCancelSaleId\" ); const CancelItemSaleButton = document . getElementById ( \"btnCancelItemSale\" ); CancelItemSaleButton . onclick = cancelSale ; init (); Now run in terminal parcel index.html All Set! Congratulations! You have created your own NFT trading marketplace and minted as well as listed your first Token in the Marketplace ! If you want to use this functionality and numerous others things like timed auction, creating collection, bidding, etc today in your app, check out the Express SDK section which gives you a plug and play SDK component for front end.","title":"Code"},{"location":"guide2/","text":"Create NFT Drop Dapp using Pandora-express SDK Intro In this guide we will build a Dapp using Express Protocol SDK through which NFT makers/celebs can mint and sell their NFT collection directly on Ethereum. Basically celebs and NFT creators can make their own collection and can drop NFTs, whenever they want. These NFT collection can later be traded using Express SDK. You need to connect a wallet, so make sure you have metamask wallet installed. Alright without further ado, let's create our Dapp! Prerequisites Some Prequisites required before building the project: NodeJS version > 16.0.0 NPM version > 6.0.0 Metamask Browser Extension Parcel Bundler(For bundling Javascript) Code 1.Creating Project: Create an empty folder in your favourite editor. We will use VScode here. 2.SDK installation Run in terminal npm init npm i pandora-express npm install -g parcel-bundler 3.Building the UI Make a index.html file and paste the following code. We have made three section here, first is for creating the collection ie.. creating the smart contract for the NFT collection, user will have to fill the input fields for Collection's Name, Symbol, Description and royalities. Now their is NFT ticket minting section, in technical terms Collection owner can mint ERC1155 token in the smart contract they have made earlier, For this we have three input fields in which owner should enter the Collection address, Token's URI and the royalities that has to be shared with other people. Now the Owner have to sell the NFT Tickets in the market, so their is a sell ticket function which takes Collection address, TokenID and Price of the token as input. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > SDK </ title > </ head > < body > < h1 > NFT Drop </ h1 > < div id = \"Collection\" > < h4 > Create Collection </ h4 > < input type = \"text\" id = \"collectionName\" required placeholder = \"Enter Collection Name\" /> < input type = \"text\" id = \"collectionSymbol\" required placeholder = \"Enter collection Symbol\" /> < input type = \"text\" id = \"collectionDescription\" required placeholder = \"Enter collection Description\" /> < input type = \"number\" id = \"collectionRoyalties\" required placeholder = \"Enter collection Royalties\" /> < button id = \"btnCreateCollection\" > Create Collection </ button > </ div > < div id = \"mintInCollection\" > < h4 > Mint in collection </ h4 > < input type = \"text\" id = \"collectionAddress\" required placeholder = \"Enter collection Address\" /> < input type = \"text\" id = \"tokenURI\" required placeholder = \"Enter TokenURI\" /> < input type = \"number\" id = \"royalties\" required placeholder = \"Enter Royalties\" /> < button id = \"btnMintInCollection\" > Mint in collection </ button > </ div > < div id = \"sellInCollection\" > < h4 > Sell in collection </ h4 > < input type = \"text\" id = \"sellCollectionAddress\" required placeholder = \"Enter collection Address\" /> < input type = \"number\" id = \"sellTokenId\" required placeholder = \"Enter TokenId\" /> < input type = \"number\" id = \"sellPrice\" required placeholder = \"Enter Price\" /> < button id = \"btnSellInCollection\" > Sell in collection </ button > </ div > < script src = \"https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\" ></ script > < script src = \"main.js\" ></ script > </ body > </ html > Now run the app with live server As we have pasted the code, now our frontend will look something like this: 4.Using SDK code with our javascript Logic Make a Javascript file, name it main.js, Now we have to import SDK function in our Dapp and make connection with blockchain using metamask. Paste the code below in main.js file. //Import createPandoraExpressSDK from SDK const { createPandoraExpressSDK } = require ( \"pandora-express\" ); const pandoraSDK = createPandoraExpressSDK (); //Connecting with Metamask wallet. const init = async () => { //check if metamask is present if ( window . ethereum ) { window . web3 = new Web3 ( window . ethereum ); await window . ethereum . enable (); console . log ( \"Connected\" ); } else { alert ( \"Metamask not found\" ); } }; Now, we have to define the Create collection function, that will create a ERC721 smart Contract, through which the owner can mint any number of NFT they want. const createCollection = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . collection . createCollection ( web3 , chainId , accounts [ 0 ], collectionName . value , //Name of Collection collectionSymbol . value , // Symbol of Collection collectionDescription . value , // Description of Collection [[ accounts [ 0 ], collectionRoyalties . value ]] // Royalities ); }; After creating collection, creators can Mint their NFT using pandoraSDK.erc721.collection.mint() function. Let's define a function for the same. const mintInCollection = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . collection . mint ( web3 , collectionAddress . value , //Address of collection Contract tokenURI . value , // URI of token accounts [ 0 ], // Account to mint NFT [[ accounts [ 0 ], collectionRoyalties . value ]] // Royalities ); } After Minting NFTs, Owners/Creators can put their NFTs on sale using pandoraSDK.erc721.collection.sellNFT() function const sellInCollection = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . collection . sellNFT ( web3 , chainId , sellCollectionAddress . value , // Collection Address sellTokenId . value , // Token ID sellPrice . value , // Base price to sell accounts [ 0 ] ); }; 5.Getting Data from User from Frontend Now as we defined the functions for our Dapp, the last step is to get the function parameters using javascript DOM. Paste the code written below to main.js. const collectionName = document . getElementById ( \"collectionName\" ); const collectionSymbol = document . getElementById ( \"collectionSymbol\" ); const collectionDescription = document . getElementById ( \"collectionDescription\" ); const collectionRoyalties = document . getElementById ( \"collectionRoyalties\" ); const CollectionButton = document . getElementById ( \"btnCreateCollection\" ); CollectionButton . onclick = createCollection ; const collectionAddress = document . getElementById ( \"collectionAddress\" ); const tokenURI = document . getElementById ( \"tokenURI\" ); const royalties = document . getElementById ( \"royalties\" ); const btnMintInCollection = document . getElementById ( \"btnMintInCollection\" ); btnMintInCollection . onclick = mintInCollection ; const sellCollectionAddress = document . getElementById ( \"sellCollectionAddress\" ); const sellTokenId = document . getElementById ( \"sellTokenId\" ); const sellPrice = document . getElementById ( \"sellPrice\" ); const btnSellInCollection = document . getElementById ( \"btnSellInCollection\" ); btnSellInCollection . onclick = sellInCollection ; init (); Now run in terminal parcel index.html That's it! Congratulations! You have created your first NFT Drop and minted as well as listed your first Token for sale in the Marketplace ! If you want to use this functionality and numerous others like timed auction, bidding, etc today in your app, check out the Express SDK section which gives you a plug and play SDK component for front end.","title":"NFT-Drop Dapp"},{"location":"guide2/#create-nft-drop-dapp-using-pandora-express-sdk","text":"","title":"Create NFT Drop Dapp using Pandora-express SDK"},{"location":"guide2/#intro","text":"In this guide we will build a Dapp using Express Protocol SDK through which NFT makers/celebs can mint and sell their NFT collection directly on Ethereum. Basically celebs and NFT creators can make their own collection and can drop NFTs, whenever they want. These NFT collection can later be traded using Express SDK. You need to connect a wallet, so make sure you have metamask wallet installed. Alright without further ado, let's create our Dapp!","title":"Intro"},{"location":"guide2/#prerequisites","text":"","title":"Prerequisites"},{"location":"guide2/#some-prequisites-required-before-building-the-project","text":"NodeJS version > 16.0.0 NPM version > 6.0.0 Metamask Browser Extension Parcel Bundler(For bundling Javascript)","title":"Some Prequisites required before building the project:"},{"location":"guide2/#code","text":"1.Creating Project: Create an empty folder in your favourite editor. We will use VScode here. 2.SDK installation Run in terminal npm init npm i pandora-express npm install -g parcel-bundler 3.Building the UI Make a index.html file and paste the following code. We have made three section here, first is for creating the collection ie.. creating the smart contract for the NFT collection, user will have to fill the input fields for Collection's Name, Symbol, Description and royalities. Now their is NFT ticket minting section, in technical terms Collection owner can mint ERC1155 token in the smart contract they have made earlier, For this we have three input fields in which owner should enter the Collection address, Token's URI and the royalities that has to be shared with other people. Now the Owner have to sell the NFT Tickets in the market, so their is a sell ticket function which takes Collection address, TokenID and Price of the token as input. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > SDK </ title > </ head > < body > < h1 > NFT Drop </ h1 > < div id = \"Collection\" > < h4 > Create Collection </ h4 > < input type = \"text\" id = \"collectionName\" required placeholder = \"Enter Collection Name\" /> < input type = \"text\" id = \"collectionSymbol\" required placeholder = \"Enter collection Symbol\" /> < input type = \"text\" id = \"collectionDescription\" required placeholder = \"Enter collection Description\" /> < input type = \"number\" id = \"collectionRoyalties\" required placeholder = \"Enter collection Royalties\" /> < button id = \"btnCreateCollection\" > Create Collection </ button > </ div > < div id = \"mintInCollection\" > < h4 > Mint in collection </ h4 > < input type = \"text\" id = \"collectionAddress\" required placeholder = \"Enter collection Address\" /> < input type = \"text\" id = \"tokenURI\" required placeholder = \"Enter TokenURI\" /> < input type = \"number\" id = \"royalties\" required placeholder = \"Enter Royalties\" /> < button id = \"btnMintInCollection\" > Mint in collection </ button > </ div > < div id = \"sellInCollection\" > < h4 > Sell in collection </ h4 > < input type = \"text\" id = \"sellCollectionAddress\" required placeholder = \"Enter collection Address\" /> < input type = \"number\" id = \"sellTokenId\" required placeholder = \"Enter TokenId\" /> < input type = \"number\" id = \"sellPrice\" required placeholder = \"Enter Price\" /> < button id = \"btnSellInCollection\" > Sell in collection </ button > </ div > < script src = \"https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\" ></ script > < script src = \"main.js\" ></ script > </ body > </ html > Now run the app with live server As we have pasted the code, now our frontend will look something like this: 4.Using SDK code with our javascript Logic Make a Javascript file, name it main.js, Now we have to import SDK function in our Dapp and make connection with blockchain using metamask. Paste the code below in main.js file. //Import createPandoraExpressSDK from SDK const { createPandoraExpressSDK } = require ( \"pandora-express\" ); const pandoraSDK = createPandoraExpressSDK (); //Connecting with Metamask wallet. const init = async () => { //check if metamask is present if ( window . ethereum ) { window . web3 = new Web3 ( window . ethereum ); await window . ethereum . enable (); console . log ( \"Connected\" ); } else { alert ( \"Metamask not found\" ); } }; Now, we have to define the Create collection function, that will create a ERC721 smart Contract, through which the owner can mint any number of NFT they want. const createCollection = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . collection . createCollection ( web3 , chainId , accounts [ 0 ], collectionName . value , //Name of Collection collectionSymbol . value , // Symbol of Collection collectionDescription . value , // Description of Collection [[ accounts [ 0 ], collectionRoyalties . value ]] // Royalities ); }; After creating collection, creators can Mint their NFT using pandoraSDK.erc721.collection.mint() function. Let's define a function for the same. const mintInCollection = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . collection . mint ( web3 , collectionAddress . value , //Address of collection Contract tokenURI . value , // URI of token accounts [ 0 ], // Account to mint NFT [[ accounts [ 0 ], collectionRoyalties . value ]] // Royalities ); } After Minting NFTs, Owners/Creators can put their NFTs on sale using pandoraSDK.erc721.collection.sellNFT() function const sellInCollection = async () => { const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); await pandoraSDK . erc721 . collection . sellNFT ( web3 , chainId , sellCollectionAddress . value , // Collection Address sellTokenId . value , // Token ID sellPrice . value , // Base price to sell accounts [ 0 ] ); }; 5.Getting Data from User from Frontend Now as we defined the functions for our Dapp, the last step is to get the function parameters using javascript DOM. Paste the code written below to main.js. const collectionName = document . getElementById ( \"collectionName\" ); const collectionSymbol = document . getElementById ( \"collectionSymbol\" ); const collectionDescription = document . getElementById ( \"collectionDescription\" ); const collectionRoyalties = document . getElementById ( \"collectionRoyalties\" ); const CollectionButton = document . getElementById ( \"btnCreateCollection\" ); CollectionButton . onclick = createCollection ; const collectionAddress = document . getElementById ( \"collectionAddress\" ); const tokenURI = document . getElementById ( \"tokenURI\" ); const royalties = document . getElementById ( \"royalties\" ); const btnMintInCollection = document . getElementById ( \"btnMintInCollection\" ); btnMintInCollection . onclick = mintInCollection ; const sellCollectionAddress = document . getElementById ( \"sellCollectionAddress\" ); const sellTokenId = document . getElementById ( \"sellTokenId\" ); const sellPrice = document . getElementById ( \"sellPrice\" ); const btnSellInCollection = document . getElementById ( \"btnSellInCollection\" ); btnSellInCollection . onclick = sellInCollection ; init (); Now run in terminal parcel index.html That's it! Congratulations! You have created your first NFT Drop and minted as well as listed your first Token for sale in the Marketplace ! If you want to use this functionality and numerous others like timed auction, bidding, etc today in your app, check out the Express SDK section which gives you a plug and play SDK component for front end.","title":"Code"},{"location":"guide3/","text":"Build a NFT-Ticketing Dapp using Pandora-express SDK Intro In this guide we will build a Dapp using Express Protocol SDK through which Event organizers or Movie makers can mint and sell their NFT Tickets directly on Ethereum . Tickets are basically a ERC1155 token that the owner want to distribute in the market and owners can also save some tickets for some particular address. Owners can then Sell these tickets in the market using Pandora Marketplace SDK. Alright without further ado, let's build our Dapp! Prerequisites Some Prequisites required before building the project: NodeJS version > 16.0.0 NPM version > 6.0.0 Metamask Browser Extension Parcel Bundler(For bundling Javascript) Code 1.Creating Project: Create an empty folder in your favourite editor. We will use VScode here. We will use Parcel for bundling the javascript code. 2.SDK installation Run in terminal npm init npm i pandora-express parcel npm install -g parcel-bundler 3.Building the UI Make a index.html file and paste the following code. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > SDK </ title > </ head > < body > < h1 > NFT Ticket Booking </ h1 > < div id = \"Collection1155\" > < h4 > Create Event(Collection) </ h4 > < input type = \"text\" id = \"collection1155Uri\" required placeholder = \"Enter Collection URI\" /> < input type = \"text\" id = \"collection1155Description\" required placeholder = \"Enter collection Description\" /> < input type = \"number\" id = \"collection1155Royalties\" required placeholder = \"Enter collection Royalties\" /> < button id = \"btnCreateCollection1155\" > Create Collection </ button > </ div > < div id = \"mintInCollection1155\" > < h4 > Mint Tickets(Tokens) </ h4 > < input type = \"text\" id = \"collection1155Address\" required placeholder = \"Enter collection Address\" /> < input type = \"text\" id = \"token1155Id\" required placeholder = \"Enter TokenId\" /> < input type = \"text\" id = \"token1155URI\" required placeholder = \"Enter TokenURI\" /> < input type = \"number\" id = \"numMintInCol1155Amount\" required placeholder = \"Enter Amount of Tokens\" /> < button id = \"btnMintInCollection1155\" > Mint in collection </ button > </ div > < div id = \"sellInCollection1155\" > < h4 > Sell Tickets(Tokens) </ h4 > < input type = \"text\" id = \"sellCollection1155Address\" required placeholder = \"Enter collection Address\" /> < input type = \"number\" id = \"sell1155TokenId\" required placeholder = \"Enter TokenId\" /> < input type = \"number\" id = \"sell1155Price\" required placeholder = \"Enter Price\" /> < input type = \"number\" id = \"numSellInCol1155Amount\" required placeholder = \"Enter Amount of Tokens\" /> < button id = \"btnSellInCollection1155\" > Sell in collection </ button > </ div > < script src = \"https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\" ></ script > < script src = \"main.js\" ></ script > </ body > </ html > Now run the app with live server As we have pasted the code, now our frontend will look something like this: 5.Getting Data from User from Frontend Now as we defined the functions for our Dapp, the last step is to get the function parameters using javascript DOM. Paste the code written below to main.js. const { createPandoraExpressSDK } = require ( \"pandora-express\" ); init = async () => { if ( window . ethereum ) { window . web3 = new Web3 ( window . ethereum ); await window . ethereum . enable (); console . log ( \"Connected\" ); } else { alert ( \"Metamask not found\" ); } }; createCollection = async () => { let ExpressSDK = createPandoraExpressSDK (); const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); const result = await ExpressSDK . erc1155 . collection . createCollection ( web3 , chainId , accounts [ 0 ], collectionURI . value , collectionDescription . value , [[ accounts [ 0 ], collectionRoyalties . value ]] ); console . log ( result ); }; mintInCollection = async () => { let ExpressSDK = createPandoraExpressSDK (); const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); const result = await ExpressSDK . erc1155 . collection . mint ( web3 , collectionAddress . value , tokenID . value , itemColNumber . value , tokenURI . value , accounts [ 0 ] ); console . log ( result ) }; sellInCollection = async () => { let ExpressSDK = createPandoraExpressSDK (); const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); const result = await ExpressSDK . erc1155 . collection . sellNFT ( web3 , chainId , sellCollectionAddress . value , sellTokenId . value , sellPrice . value , accounts [ 0 ], itemSellNumber . value ); console . log ( result ) }; const collectionURI = document . getElementById ( \"collection1155Uri\" ); const collectionDescription = document . getElementById ( \"collection1155Description\" ); const collectionRoyalties = document . getElementById ( \"collection1155Royalties\" ); const CollectionButton = document . getElementById ( \"btnCreateCollection1155\" ); CollectionButton . onclick = createCollection ; const collectionAddress = document . getElementById ( \"collection1155Address\" ); const tokenURI = document . getElementById ( \"token1155URI\" ); const tokenID = document . getElementById ( \"token1155Id\" ); const itemColNumber = document . getElementById ( \"numMintInCol1155Amount\" ); const btnMintInCollection = document . getElementById ( \"btnMintInCollection1155\" ); btnMintInCollection . onclick = mintInCollection ; const sellCollectionAddress = document . getElementById ( \"sellCollection1155Address\" ); const sellTokenId = document . getElementById ( \"sell1155TokenId\" ); const sellPrice = document . getElementById ( \"sell1155Price\" ); const itemSellNumber = document . getElementById ( \"numSellInCol1155Amount\" ); const btnSellInCollection = document . getElementById ( \"btnSellInCollection1155\" ); btnSellInCollection . onclick = sellInCollection ; init (); Now run in terminal parcel index.html That's it! Congratulations! You have created your NFT Ticket Booking Dapp, minted as well as listed your Event Tickets for sale in the Marketplace ! If you want to use this functionality and numerous others like timed auction, bidding, etc today in your app, check out the Express SDK section which gives you a plug and play SDK component for front end.","title":"NFT-Ticket Booking Dapp"},{"location":"guide3/#build-a-nft-ticketing-dapp-using-pandora-express-sdk","text":"","title":"Build a NFT-Ticketing Dapp using Pandora-express SDK"},{"location":"guide3/#intro","text":"In this guide we will build a Dapp using Express Protocol SDK through which Event organizers or Movie makers can mint and sell their NFT Tickets directly on Ethereum . Tickets are basically a ERC1155 token that the owner want to distribute in the market and owners can also save some tickets for some particular address. Owners can then Sell these tickets in the market using Pandora Marketplace SDK. Alright without further ado, let's build our Dapp!","title":"Intro"},{"location":"guide3/#prerequisites","text":"","title":"Prerequisites"},{"location":"guide3/#some-prequisites-required-before-building-the-project","text":"NodeJS version > 16.0.0 NPM version > 6.0.0 Metamask Browser Extension Parcel Bundler(For bundling Javascript)","title":"Some Prequisites required before building the project:"},{"location":"guide3/#code","text":"1.Creating Project: Create an empty folder in your favourite editor. We will use VScode here. We will use Parcel for bundling the javascript code. 2.SDK installation Run in terminal npm init npm i pandora-express parcel npm install -g parcel-bundler 3.Building the UI Make a index.html file and paste the following code. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < title > SDK </ title > </ head > < body > < h1 > NFT Ticket Booking </ h1 > < div id = \"Collection1155\" > < h4 > Create Event(Collection) </ h4 > < input type = \"text\" id = \"collection1155Uri\" required placeholder = \"Enter Collection URI\" /> < input type = \"text\" id = \"collection1155Description\" required placeholder = \"Enter collection Description\" /> < input type = \"number\" id = \"collection1155Royalties\" required placeholder = \"Enter collection Royalties\" /> < button id = \"btnCreateCollection1155\" > Create Collection </ button > </ div > < div id = \"mintInCollection1155\" > < h4 > Mint Tickets(Tokens) </ h4 > < input type = \"text\" id = \"collection1155Address\" required placeholder = \"Enter collection Address\" /> < input type = \"text\" id = \"token1155Id\" required placeholder = \"Enter TokenId\" /> < input type = \"text\" id = \"token1155URI\" required placeholder = \"Enter TokenURI\" /> < input type = \"number\" id = \"numMintInCol1155Amount\" required placeholder = \"Enter Amount of Tokens\" /> < button id = \"btnMintInCollection1155\" > Mint in collection </ button > </ div > < div id = \"sellInCollection1155\" > < h4 > Sell Tickets(Tokens) </ h4 > < input type = \"text\" id = \"sellCollection1155Address\" required placeholder = \"Enter collection Address\" /> < input type = \"number\" id = \"sell1155TokenId\" required placeholder = \"Enter TokenId\" /> < input type = \"number\" id = \"sell1155Price\" required placeholder = \"Enter Price\" /> < input type = \"number\" id = \"numSellInCol1155Amount\" required placeholder = \"Enter Amount of Tokens\" /> < button id = \"btnSellInCollection1155\" > Sell in collection </ button > </ div > < script src = \"https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\" ></ script > < script src = \"main.js\" ></ script > </ body > </ html > Now run the app with live server As we have pasted the code, now our frontend will look something like this: 5.Getting Data from User from Frontend Now as we defined the functions for our Dapp, the last step is to get the function parameters using javascript DOM. Paste the code written below to main.js. const { createPandoraExpressSDK } = require ( \"pandora-express\" ); init = async () => { if ( window . ethereum ) { window . web3 = new Web3 ( window . ethereum ); await window . ethereum . enable (); console . log ( \"Connected\" ); } else { alert ( \"Metamask not found\" ); } }; createCollection = async () => { let ExpressSDK = createPandoraExpressSDK (); const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); const result = await ExpressSDK . erc1155 . collection . createCollection ( web3 , chainId , accounts [ 0 ], collectionURI . value , collectionDescription . value , [[ accounts [ 0 ], collectionRoyalties . value ]] ); console . log ( result ); }; mintInCollection = async () => { let ExpressSDK = createPandoraExpressSDK (); const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); const result = await ExpressSDK . erc1155 . collection . mint ( web3 , collectionAddress . value , tokenID . value , itemColNumber . value , tokenURI . value , accounts [ 0 ] ); console . log ( result ) }; sellInCollection = async () => { let ExpressSDK = createPandoraExpressSDK (); const accounts = await web3 . eth . getAccounts (); const chainId = await web3 . eth . net . getId (); console . log ( chainId ); const result = await ExpressSDK . erc1155 . collection . sellNFT ( web3 , chainId , sellCollectionAddress . value , sellTokenId . value , sellPrice . value , accounts [ 0 ], itemSellNumber . value ); console . log ( result ) }; const collectionURI = document . getElementById ( \"collection1155Uri\" ); const collectionDescription = document . getElementById ( \"collection1155Description\" ); const collectionRoyalties = document . getElementById ( \"collection1155Royalties\" ); const CollectionButton = document . getElementById ( \"btnCreateCollection1155\" ); CollectionButton . onclick = createCollection ; const collectionAddress = document . getElementById ( \"collection1155Address\" ); const tokenURI = document . getElementById ( \"token1155URI\" ); const tokenID = document . getElementById ( \"token1155Id\" ); const itemColNumber = document . getElementById ( \"numMintInCol1155Amount\" ); const btnMintInCollection = document . getElementById ( \"btnMintInCollection1155\" ); btnMintInCollection . onclick = mintInCollection ; const sellCollectionAddress = document . getElementById ( \"sellCollection1155Address\" ); const sellTokenId = document . getElementById ( \"sell1155TokenId\" ); const sellPrice = document . getElementById ( \"sell1155Price\" ); const itemSellNumber = document . getElementById ( \"numSellInCol1155Amount\" ); const btnSellInCollection = document . getElementById ( \"btnSellInCollection1155\" ); btnSellInCollection . onclick = sellInCollection ; init (); Now run in terminal parcel index.html That's it! Congratulations! You have created your NFT Ticket Booking Dapp, minted as well as listed your Event Tickets for sale in the Marketplace ! If you want to use this functionality and numerous others like timed auction, bidding, etc today in your app, check out the Express SDK section which gives you a plug and play SDK component for front end.","title":"Code"},{"location":"guide4/","text":"Create NFT Lending and Borrowing using Pandora-express SDK Intro In this guide we will make NFT Lending and Borrowing Dapp using Express Protocol SDK through which anyone can lend or borrow tokens. We will use Pandora Public ERC721 contract for NFT minting and Pandora Market Contract for Lending through listing the NFT. You also need to connect a wallet, so make sure you have metamask wallet installed. Alright without further ado, let's create our marketplace! Prerequisites Some Prequisites required before building the project: NodeJS version > 16.0.0 NPM version > 6.0.0 Metamask Browser Extension Parcel Bundler(For bundling Javascript) Code 1.Creating Project: Create an empty folder in your favourite editor. We will use VScode here. 2.SDK installation Run in terminal npm init npm i pandora-express npm install -g parcel-bundler 3.Building the UI Make a index.html file and paste the following code. Here we will make seven input fields, User have to enter the URI to mint the NFT, and next fields we need to approve the NFT by taking the aurguments NFT contract address and NFT token ID. On next field we need to add NFT to the listing and enter the aurguments Loan Amount, intrest Amount, Time Period(in days) and Max Time Period(in days). On next field the lender will accpet the Loan and enters the aurguments NFT loan id, Loan Amount(in wei), intrest Amount(in wei). On nest field if the Borrower wants to end the loan then we will use End Loan to close the Loan. On next field Extend we will need to enter the Loan ID to extend upto the MAX time period entered in Creat function. and next if any of the lender gives you loan you can cancel and creat an other Loan. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Test NFT Lending </ title > </ head > < body > < script src = \"https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\" ></ script > < script type = \"module\" src = \"main.js\" ></ script > < div > < input type = \"text\" id = \"mintNFT\" placeholder = \"Enter URI to mint\" > < button id = \"mintBtn\" > Mint </ button > </ div > < br > < br > < div > < input type = \"text\" id = \"nftContractAddress\" placeholder = \"NFT Contract Address\" > < input type = \"text\" id = \"nftTokenId\" placeholder = \"NFT Token Id\" > < button id = \"approveBtn\" > Approve </ button > </ div > < br > < br > < div > < input type = \"text\" id = \"nftContractAddress1\" placeholder = \"NFT Contract Address\" > < br > < input type = \"text\" id = \"nftTokenId1\" placeholder = \"NFT Token Id\" > < br > < input type = \"number\" id = \"loanAmount\" placeholder = \"Loan Amount(in wei)\" > < br > < input type = \"number\" id = \"interestAmount\" placeholder = \"Interest Amount(in wei)\" > < br > < input type = \"text\" id = \"timePeriod\" placeholder = \"Time Period(in days)\" > < br > < input type = \"text\" id = \"maxTimePeriod\" placeholder = \"Max Time Period(in days)\" > < br > < button id = \"createBtn\" > Create </ button > </ div > < br > < br > < div > < input type = \"number\" id = \"loanId\" placeholder = \"NFT Loan Id\" > < br > < input type = \"number\" id = \"loanAmount1\" placeholder = \"Loan Amount(in wei)\" > < br > < input type = \"number\" id = \"interestAmount1\" placeholder = \"Interest Amount(in wei)\" > < br > < button id = \"acceptBtn\" > Accept </ button > < br > < br > </ div > < div > < input type = \"number\" id = \"loanId2\" placeholder = \"NFT Loan Id\" > < br > < input type = \"number\" id = \"loanAmount2\" placeholder = \"Loan Amount(in wei)\" > < br > < input type = \"number\" id = \"interestAmount2\" placeholder = \"Interest Amount(in wei)\" > < br > < button id = \"endBtn\" > End Loan </ button > < br > < br > </ div > < div > < input type = \"number\" id = \"extendLoanId\" placeholder = \"Extend Loan Id\" > < br > < button id = \"extendBtn\" > Extend </ button > </ div > < br >< br > < div > < input type = \"number\" id = \"cancelLoanId\" placeholder = \"Cancel Loan Id\" > < br > < button id = \"cancelBtn\" > Cancel </ button > </ div > </ body > </ html > Now run the app with live server. As we have pasted the code, now our frontend will look something like this: 4.Using SDK code with our javascript Logic Make a Javascript file, name it main.js, Now we have to import SDK function in our Dapp and add Mint function and make connection with blockchain using metamask. Paste the code below in main.js file. //Import createPandoraExpressSDK from SDK const { createPandoraExpressSDK } = require ( \"pandora-express\" ); const pandoraSDK = createPandoraExpressSDK (); mint = async () =>{ //get current account address const accounts = await web3 . eth . getAccounts (); //Get ChainID of current account const chainId = await web3 . eth . net . getId (); //Mint NFT using SDK erc721 nft mint console . log ( chainId ); await pandoraSDK . erc721 . nft . mint ( web3 , chainId , accounts [ 0 ], itemURI . value , [ [ accounts [ 0 ], 100 ], ]); } const itemURI = document . getElementById ( \"mintNFT\" ); const createItemButton = document . getElementById ( \"mintBtn\" ); createItemButton . onclick = mint ; const REQUEST_STATUS = [ \"Pending\" , \"Active\" , \"Cancelled\" , \"Ended\" , \"Defaulted\" ]; const LENDING_CONTRACT_ADDRESS = '0x67490a4814a5C127B0522b40d2DaEdF6104BdeA6' ; //Connecting with Metamask wallet. const init = async () => { //check if metamask is present if ( window . ethereum ) { window . web3 = new Web3 ( window . ethereum ); await window . ethereum . enable (); console . log ( \"Connected\" ); } else { alert ( \"Metamask not found\" ); } }; const nftContractAddress = document . getElementById ( \"nftContractAddress\" ); const tokenId = document . getElementById ( \"nftTokenId\" ) We have minted a NFT using the SDK now, we can approove the NFT by using approveNFT function of the SDK. Define the approveNFT function as written below. approveNFT = async () => { const web3 = new Web3 ( window . ethereum ); const accounts = await web3 . eth . getAccounts (); console . log ( accounts [ 0 ]); const instance = new web3 . eth . Contract ( tokenABI , nftContractAddress . value , { from : accounts [ 0 ]}); await instance . methods . approve ( LENDING_CONTRACT_ADDRESS , tokenId . value ) . send ({ from : accounts [ 0 ], }) . once ( \"receipt\" , ( receipt ) => { console . log ( receipt ); }) . catch (( err ) => { console . log ( err ); }); }; We have approved the NFT!!, now that NFT contract address has been approved now it can have access to Lending and Borrowing. now you can creat a loan by createLoan function that will creat a loan on the NFT contract address. Try pasting the code below for Creating a Loan. createLoan = async () => { const web3 = new Web3 ( window . ethereum ); const accounts = await web3 . eth . getAccounts (); const instance = new web3 . eth . Contract ( contractABI , LENDING_CONTRACT_ADDRESS , { from : accounts [ 0 ]}); await instance . methods . createLoan ( nftAddress . value , nftId . value , loanAmount . value . toString (), interestAmount . value . toString (), totalTimePeriod . value * 86400 , maxTimePeriod . value ). send ({ from : accounts [ 0 ], }) . once ( \"receipt\" , ( receipt ) => { console . log ( receipt ); }) . catch (( err ) => { console . log ( err ); }); }; Now we have created a loan which takes NFT Contract address, NFT Token id, Loan Amount(in wei), Intrest Amount(in wei), Time Period(in days), Max time period(in days). For Lender to accept the Loan we need to use acceptLoan function. Try pasting the code below for accepting the Loan. acceptLoan = async () =>{ const web3 = new Web3 ( window . ethereum ); const accounts = await web3 . eth . getAccounts (); const instance = new web3 . eth . Contract ( contractABI , LENDING_CONTRACT_ADDRESS , { from : accounts [ 0 ]}); const sum = ethLoanAmount . value . toString (); await instance . methods . acceptLoan ( loanID . value ). send ({ value : sum , from : accounts [ 0 ], }) . once ( \"receipt\" , ( receipt ) => { console . log ( receipt ); }) . catch (( err ) => { console . log ( err ); }); } Now if borrower wants to end the loan before the period he can use endLoan function. we need to add endLoan function to our main.ja file. Try pasting the code below to end the Loan. endLoan = async () => { const web3 = new Web3 ( window . ethereum ); const accounts = await web3 . eth . getAccounts (); const instance = new web3 . eth . Contract ( contractABI , LENDING_CONTRACT_ADDRESS , { from : accounts [ 0 ]}); const sum = ethLoanAmount1 . value * 1 + ethInterestAmount1 . value * 1 ; console . log ( sum ); await instance . methods . endLoan ( loanID1 . value ). send ({ value : sum . toString (), from : accounts [ 0 ], }) . once ( \"receipt\" , ( receipt ) => { console . log ( receipt ); }) . catch (( err ) => { console . log ( err ); }); } Now when we creat a lone we need to enter \"MAX Time Period(in days)\" this are the days that can be extended after the dead-line to use this functionality we have extendLoan function. Try pasting the code below to extend the Loan. extendLoan = async () => { const web3 = new Web3 ( window . ethereum ); const accounts = await web3 . eth . getAccounts (); const instance = new web3 . eth . Contract ( contractABI , LENDING_CONTRACT_ADDRESS , { from : accounts [ 0 ]}); await instance . methods . extendLoan ( extendLoanId . value ). send ({ from : accounts [ 0 ], }) . once ( \"receipt\" , ( receipt ) => { console . log ( receipt ); }) . catch (( err ) => { console . log ( err ); }); } Now if a borrower wants to cancel a listing he can use cancelLoan function. Try pasting the code below to cancel the Loan. cancelLoan = async () => { const web3 = new Web3 ( window . ethereum ); const accounts = await web3 . eth . getAccounts (); const instance = new web3 . eth . Contract ( contractABI , LENDING_CONTRACT_ADDRESS , { from : accounts [ 0 ]}); await instance . methods . cancelLoan ( cancelLoanId . value ). send ({ from : accounts [ 0 ], }) . once ( \"receipt\" , ( receipt ) => { console . log ( receipt ); }) . catch (( err ) => { console . log ( err ); }); } 5.Getting Data from User from Frontend Now as we defined the functions for our NFT Lending and Borrowing, the last step is to get the function parameters using javascript DOM. Paste the code written below to main.js. const approves = document . getElementById ( \"approveBtn\" ); approves . onclick = approveNFT ; const nftAddress = document . getElementById ( \"nftContractAddress1\" ); const nftId = document . getElementById ( \"nftTokenId1\" ); const loanAmount = document . getElementById ( \"loanAmount\" ); const interestAmount = document . getElementById ( \"interestAmount\" ); const totalTimePeriod = document . getElementById ( \"timePeriod\" ); const maxTimePeriod = document . getElementById ( \"maxTimePeriod\" ); const create = document . getElementById ( \"createBtn\" ); create . onclick = createLoan ; const loanID = document . getElementById ( \"loanId\" ); const ethLoanAmount = document . getElementById ( \"loanAmount1\" ); const ethInterestAmount = document . getElementById ( \"interestAmount1\" ); const accept = document . getElementById ( \"acceptBtn\" ); accept . onclick = acceptLoan ; const extendLoanId = document . getElementById ( \"extendLoanId\" ); const extend = document . getElementById ( \"extendBtn\" ) extend . onclick = extendLoan ; const cancelLoanId = document . getElementById ( \"cancelLoanId\" ); const cancel = document . getElementById ( \"cancelBtn\" ) cancel . onclick = cancelLoan ; const loanID1 = document . getElementById ( \"loanId2\" ); const ethLoanAmount1 = document . getElementById ( \"loanAmount2\" ); const ethInterestAmount1 = document . getElementById ( \"interestAmount2\" ); const end = document . getElementById ( \"endBtn\" ) end . onclick = endLoan ; init (); Now run in terminal parcel index.html That's it! Congratulations! You have created your own NFT Lending and Borrowing Dapp If you want to use this functionality and numerous others like timed auction, creating collection, bidding, etc today in your app, check out the section which gives you a plug and play SDK component for front end.","title":"NFT-Lending and Borrowing Dapp"},{"location":"guide4/#create-nft-lending-and-borrowing-using-pandora-express-sdk","text":"","title":"Create NFT Lending and Borrowing using Pandora-express SDK"},{"location":"guide4/#intro","text":"In this guide we will make NFT Lending and Borrowing Dapp using Express Protocol SDK through which anyone can lend or borrow tokens. We will use Pandora Public ERC721 contract for NFT minting and Pandora Market Contract for Lending through listing the NFT. You also need to connect a wallet, so make sure you have metamask wallet installed. Alright without further ado, let's create our marketplace!","title":"Intro"},{"location":"guide4/#prerequisites","text":"","title":"Prerequisites"},{"location":"guide4/#some-prequisites-required-before-building-the-project","text":"NodeJS version > 16.0.0 NPM version > 6.0.0 Metamask Browser Extension Parcel Bundler(For bundling Javascript)","title":"Some Prequisites required before building the project:"},{"location":"guide4/#code","text":"1.Creating Project: Create an empty folder in your favourite editor. We will use VScode here. 2.SDK installation Run in terminal npm init npm i pandora-express npm install -g parcel-bundler 3.Building the UI Make a index.html file and paste the following code. Here we will make seven input fields, User have to enter the URI to mint the NFT, and next fields we need to approve the NFT by taking the aurguments NFT contract address and NFT token ID. On next field we need to add NFT to the listing and enter the aurguments Loan Amount, intrest Amount, Time Period(in days) and Max Time Period(in days). On next field the lender will accpet the Loan and enters the aurguments NFT loan id, Loan Amount(in wei), intrest Amount(in wei). On nest field if the Borrower wants to end the loan then we will use End Loan to close the Loan. On next field Extend we will need to enter the Loan ID to extend upto the MAX time period entered in Creat function. and next if any of the lender gives you loan you can cancel and creat an other Loan. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Test NFT Lending </ title > </ head > < body > < script src = \"https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\" ></ script > < script type = \"module\" src = \"main.js\" ></ script > < div > < input type = \"text\" id = \"mintNFT\" placeholder = \"Enter URI to mint\" > < button id = \"mintBtn\" > Mint </ button > </ div > < br > < br > < div > < input type = \"text\" id = \"nftContractAddress\" placeholder = \"NFT Contract Address\" > < input type = \"text\" id = \"nftTokenId\" placeholder = \"NFT Token Id\" > < button id = \"approveBtn\" > Approve </ button > </ div > < br > < br > < div > < input type = \"text\" id = \"nftContractAddress1\" placeholder = \"NFT Contract Address\" > < br > < input type = \"text\" id = \"nftTokenId1\" placeholder = \"NFT Token Id\" > < br > < input type = \"number\" id = \"loanAmount\" placeholder = \"Loan Amount(in wei)\" > < br > < input type = \"number\" id = \"interestAmount\" placeholder = \"Interest Amount(in wei)\" > < br > < input type = \"text\" id = \"timePeriod\" placeholder = \"Time Period(in days)\" > < br > < input type = \"text\" id = \"maxTimePeriod\" placeholder = \"Max Time Period(in days)\" > < br > < button id = \"createBtn\" > Create </ button > </ div > < br > < br > < div > < input type = \"number\" id = \"loanId\" placeholder = \"NFT Loan Id\" > < br > < input type = \"number\" id = \"loanAmount1\" placeholder = \"Loan Amount(in wei)\" > < br > < input type = \"number\" id = \"interestAmount1\" placeholder = \"Interest Amount(in wei)\" > < br > < button id = \"acceptBtn\" > Accept </ button > < br > < br > </ div > < div > < input type = \"number\" id = \"loanId2\" placeholder = \"NFT Loan Id\" > < br > < input type = \"number\" id = \"loanAmount2\" placeholder = \"Loan Amount(in wei)\" > < br > < input type = \"number\" id = \"interestAmount2\" placeholder = \"Interest Amount(in wei)\" > < br > < button id = \"endBtn\" > End Loan </ button > < br > < br > </ div > < div > < input type = \"number\" id = \"extendLoanId\" placeholder = \"Extend Loan Id\" > < br > < button id = \"extendBtn\" > Extend </ button > </ div > < br >< br > < div > < input type = \"number\" id = \"cancelLoanId\" placeholder = \"Cancel Loan Id\" > < br > < button id = \"cancelBtn\" > Cancel </ button > </ div > </ body > </ html > Now run the app with live server. As we have pasted the code, now our frontend will look something like this: 4.Using SDK code with our javascript Logic Make a Javascript file, name it main.js, Now we have to import SDK function in our Dapp and add Mint function and make connection with blockchain using metamask. Paste the code below in main.js file. //Import createPandoraExpressSDK from SDK const { createPandoraExpressSDK } = require ( \"pandora-express\" ); const pandoraSDK = createPandoraExpressSDK (); mint = async () =>{ //get current account address const accounts = await web3 . eth . getAccounts (); //Get ChainID of current account const chainId = await web3 . eth . net . getId (); //Mint NFT using SDK erc721 nft mint console . log ( chainId ); await pandoraSDK . erc721 . nft . mint ( web3 , chainId , accounts [ 0 ], itemURI . value , [ [ accounts [ 0 ], 100 ], ]); } const itemURI = document . getElementById ( \"mintNFT\" ); const createItemButton = document . getElementById ( \"mintBtn\" ); createItemButton . onclick = mint ; const REQUEST_STATUS = [ \"Pending\" , \"Active\" , \"Cancelled\" , \"Ended\" , \"Defaulted\" ]; const LENDING_CONTRACT_ADDRESS = '0x67490a4814a5C127B0522b40d2DaEdF6104BdeA6' ; //Connecting with Metamask wallet. const init = async () => { //check if metamask is present if ( window . ethereum ) { window . web3 = new Web3 ( window . ethereum ); await window . ethereum . enable (); console . log ( \"Connected\" ); } else { alert ( \"Metamask not found\" ); } }; const nftContractAddress = document . getElementById ( \"nftContractAddress\" ); const tokenId = document . getElementById ( \"nftTokenId\" ) We have minted a NFT using the SDK now, we can approove the NFT by using approveNFT function of the SDK. Define the approveNFT function as written below. approveNFT = async () => { const web3 = new Web3 ( window . ethereum ); const accounts = await web3 . eth . getAccounts (); console . log ( accounts [ 0 ]); const instance = new web3 . eth . Contract ( tokenABI , nftContractAddress . value , { from : accounts [ 0 ]}); await instance . methods . approve ( LENDING_CONTRACT_ADDRESS , tokenId . value ) . send ({ from : accounts [ 0 ], }) . once ( \"receipt\" , ( receipt ) => { console . log ( receipt ); }) . catch (( err ) => { console . log ( err ); }); }; We have approved the NFT!!, now that NFT contract address has been approved now it can have access to Lending and Borrowing. now you can creat a loan by createLoan function that will creat a loan on the NFT contract address. Try pasting the code below for Creating a Loan. createLoan = async () => { const web3 = new Web3 ( window . ethereum ); const accounts = await web3 . eth . getAccounts (); const instance = new web3 . eth . Contract ( contractABI , LENDING_CONTRACT_ADDRESS , { from : accounts [ 0 ]}); await instance . methods . createLoan ( nftAddress . value , nftId . value , loanAmount . value . toString (), interestAmount . value . toString (), totalTimePeriod . value * 86400 , maxTimePeriod . value ). send ({ from : accounts [ 0 ], }) . once ( \"receipt\" , ( receipt ) => { console . log ( receipt ); }) . catch (( err ) => { console . log ( err ); }); }; Now we have created a loan which takes NFT Contract address, NFT Token id, Loan Amount(in wei), Intrest Amount(in wei), Time Period(in days), Max time period(in days). For Lender to accept the Loan we need to use acceptLoan function. Try pasting the code below for accepting the Loan. acceptLoan = async () =>{ const web3 = new Web3 ( window . ethereum ); const accounts = await web3 . eth . getAccounts (); const instance = new web3 . eth . Contract ( contractABI , LENDING_CONTRACT_ADDRESS , { from : accounts [ 0 ]}); const sum = ethLoanAmount . value . toString (); await instance . methods . acceptLoan ( loanID . value ). send ({ value : sum , from : accounts [ 0 ], }) . once ( \"receipt\" , ( receipt ) => { console . log ( receipt ); }) . catch (( err ) => { console . log ( err ); }); } Now if borrower wants to end the loan before the period he can use endLoan function. we need to add endLoan function to our main.ja file. Try pasting the code below to end the Loan. endLoan = async () => { const web3 = new Web3 ( window . ethereum ); const accounts = await web3 . eth . getAccounts (); const instance = new web3 . eth . Contract ( contractABI , LENDING_CONTRACT_ADDRESS , { from : accounts [ 0 ]}); const sum = ethLoanAmount1 . value * 1 + ethInterestAmount1 . value * 1 ; console . log ( sum ); await instance . methods . endLoan ( loanID1 . value ). send ({ value : sum . toString (), from : accounts [ 0 ], }) . once ( \"receipt\" , ( receipt ) => { console . log ( receipt ); }) . catch (( err ) => { console . log ( err ); }); } Now when we creat a lone we need to enter \"MAX Time Period(in days)\" this are the days that can be extended after the dead-line to use this functionality we have extendLoan function. Try pasting the code below to extend the Loan. extendLoan = async () => { const web3 = new Web3 ( window . ethereum ); const accounts = await web3 . eth . getAccounts (); const instance = new web3 . eth . Contract ( contractABI , LENDING_CONTRACT_ADDRESS , { from : accounts [ 0 ]}); await instance . methods . extendLoan ( extendLoanId . value ). send ({ from : accounts [ 0 ], }) . once ( \"receipt\" , ( receipt ) => { console . log ( receipt ); }) . catch (( err ) => { console . log ( err ); }); } Now if a borrower wants to cancel a listing he can use cancelLoan function. Try pasting the code below to cancel the Loan. cancelLoan = async () => { const web3 = new Web3 ( window . ethereum ); const accounts = await web3 . eth . getAccounts (); const instance = new web3 . eth . Contract ( contractABI , LENDING_CONTRACT_ADDRESS , { from : accounts [ 0 ]}); await instance . methods . cancelLoan ( cancelLoanId . value ). send ({ from : accounts [ 0 ], }) . once ( \"receipt\" , ( receipt ) => { console . log ( receipt ); }) . catch (( err ) => { console . log ( err ); }); } 5.Getting Data from User from Frontend Now as we defined the functions for our NFT Lending and Borrowing, the last step is to get the function parameters using javascript DOM. Paste the code written below to main.js. const approves = document . getElementById ( \"approveBtn\" ); approves . onclick = approveNFT ; const nftAddress = document . getElementById ( \"nftContractAddress1\" ); const nftId = document . getElementById ( \"nftTokenId1\" ); const loanAmount = document . getElementById ( \"loanAmount\" ); const interestAmount = document . getElementById ( \"interestAmount\" ); const totalTimePeriod = document . getElementById ( \"timePeriod\" ); const maxTimePeriod = document . getElementById ( \"maxTimePeriod\" ); const create = document . getElementById ( \"createBtn\" ); create . onclick = createLoan ; const loanID = document . getElementById ( \"loanId\" ); const ethLoanAmount = document . getElementById ( \"loanAmount1\" ); const ethInterestAmount = document . getElementById ( \"interestAmount1\" ); const accept = document . getElementById ( \"acceptBtn\" ); accept . onclick = acceptLoan ; const extendLoanId = document . getElementById ( \"extendLoanId\" ); const extend = document . getElementById ( \"extendBtn\" ) extend . onclick = extendLoan ; const cancelLoanId = document . getElementById ( \"cancelLoanId\" ); const cancel = document . getElementById ( \"cancelBtn\" ) cancel . onclick = cancelLoan ; const loanID1 = document . getElementById ( \"loanId2\" ); const ethLoanAmount1 = document . getElementById ( \"loanAmount2\" ); const ethInterestAmount1 = document . getElementById ( \"interestAmount2\" ); const end = document . getElementById ( \"endBtn\" ) end . onclick = endLoan ; init (); Now run in terminal parcel index.html That's it! Congratulations! You have created your own NFT Lending and Borrowing Dapp If you want to use this functionality and numerous others like timed auction, creating collection, bidding, etc today in your app, check out the section which gives you a plug and play SDK component for front end.","title":"Code"},{"location":"sdk/gettingStarted/","text":"Installation SDK is written in Javascript. To use SDK, install it through npm npm install pandora-express After installation, SDK can be initialized In the main.js file, Paste the following code, this will initialize PandoraExpressSDK import { createPandoraExpressSDK } from \"pandora-express\" ; const ExpressSDK = createPandoraExpressSDK (); For further usage of SDK with frontend, you can refer to SDK-Usecases section Usage With Express Protocol SDK, one can: Mint ERC721/ERC1155 Token Sell/Buy Tokens Put Tokens on Auction Create/accept bids for auction Deploy personal ERC721/ERC1155 contract(Collection) Mint, trade, and auction tokens inside Collection","title":"Getting Started"},{"location":"sdk/gettingStarted/#installation","text":"SDK is written in Javascript. To use SDK, install it through npm npm install pandora-express After installation, SDK can be initialized In the main.js file, Paste the following code, this will initialize PandoraExpressSDK import { createPandoraExpressSDK } from \"pandora-express\" ; const ExpressSDK = createPandoraExpressSDK (); For further usage of SDK with frontend, you can refer to SDK-Usecases section","title":"Installation"},{"location":"sdk/gettingStarted/#usage","text":"With Express Protocol SDK, one can: Mint ERC721/ERC1155 Token Sell/Buy Tokens Put Tokens on Auction Create/accept bids for auction Deploy personal ERC721/ERC1155 contract(Collection) Mint, trade, and auction tokens inside Collection","title":"Usage"},{"location":"sdk/overview/","text":"Express Protocol SDK enables any Web2 developer to create out of the box applications around NFTs and NFTMarketplace without getting into the nitty-gritty of Blockchain and Smart Contracts. Currently, The SDK operates on these networks: Rinkeby Testnet (network id - 4) Ropsten Testnet (network id - 3) BSC Testnet (network id - 97) Polygon-Mumbai Testnet (network id - 80001) With Express Protocol SDK, any user can deploy ERC721 and ERC1155 contracts and mint, trade and auction NFTs without diving deep into the smart contract source code. All the ERC721 SDK functions can be quickly looked at here .","title":"Overview"},{"location":"sdk/SDKFunctions/erc1155/","text":"Following are the SDK functions for ERC1155 standard: ExpressSDK.erc1155.nft.mint() ExpressSDK.erc1155.nft.burn() ExpressSDK.erc1155.order.sellNFT() ExpressSDK.erc1155.order.sellNFTbyBid() ExpressSDK.erc1155.order.cancelSale() ExpressSDK.erc1155.order.buyNFT() ExpressSDK.erc1155.order.bid() ExpressSDK.erc1155.order.acceptBid() ExpressSDK.erc1155.order.withdrawBid() ExpressSDK.erc1155.collection.createCollection() ExpressSDK.erc1155.collection.mint() ExpressSDK.erc1155.collection.burn() ExpressSDK.erc1155.collection.sellNFT() ExpressSDK.erc1155.collection.sellNFTbyBid() ExpressSDK.erc1155.collection.cancelSale() ExpressSDK.erc1155.collection.buyNFT() ExpressSDK.erc1155.collection.bid() ExpressSDK.erc1155.collection.acceptBid() ExpressSDK.erc1155.collection.withdrawBid()","title":"ERC1155"},{"location":"sdk/SDKFunctions/erc721/","text":"Following are the SDK functions for ERC721 standard: ExpressSDK.erc721.nft.mint() ExpressSDK.erc721.nft.batchMint() ExpressSDK.erc721.nft.burn() ExpressSDK.erc721.order.sellNFT() ExpressSDK.erc721.order.sellNFTbyBid() ExpressSDK.erc721.order.cancelSale() ExpressSDK.erc721.order.buyNFT() ExpressSDK.erc721.order.bid() ExpressSDK.erc721.order.acceptBid() ExpressSDK.erc721.order.withdrawBid() ExpressSDK.erc721.collection.createCollection() ExpressSDK.erc721.collection.mint() ExpressSDK.erc721.collection.batchMint() ExpressSDK.erc721.collection.burn() ExpressSDK.erc721.collection.sellNFT() ExpressSDK.erc721.collection.sellNFTbyBid() ExpressSDK.erc721.collection.cancelSale() ExpressSDK.erc721.collection.buyNFT() ExpressSDK.erc721.collection.bid() ExpressSDK.erc721.collection.acceptBid() ExpressSDK.erc721.collection.withdrawBid()","title":"ERC721"},{"location":"sdk/erc1155/PersonalCollection/10_WithdrawingBid/","text":"const result = await ExpressSDK . erc1155 . collection . withdrawBid ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain saleId , // Sale Id of the item on auction bidId , //Bid Id of the buyer in an auction buyerAddress // Address of the bidder ); When the bidder wants to withdraw their bid, they can do so using this function. After successful execution of the function bid will be removed from the auction and the money will be transferred back to the bidder.","title":"Withdraw"},{"location":"sdk/erc1155/PersonalCollection/11_CancellingSale/","text":"const result = await ExpressSDK . erc1155 . collection . cancelSale ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain sellerAddress , // Address of the seller saleId // Sale Id of the item ); After the successful execution of this function, the item that was on direct sale or auction sale will be removed from sale","title":"Cancel Sale"},{"location":"sdk/erc1155/PersonalCollection/1_PersonalCollection/","text":"A personal collection can be deployed using SDK and inside a collection, user can furthur mint and trade tokens. const result = await ExpressSDK . erc1155 . collection . createCollection ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain ownerAddress , // Address of the collection creator uri , // URL of Token description , //description of token collectionRoyalties // Royalties received by the owner ); When this function is executed an event is emitted ERC1155Deployed which contains the address of the collection. const collectionContractAddress = result . events . ERC1155Deployed . returnValues . _tokenAddress ; This variable will contain the required contract address of the collection.","title":"Create Collection"},{"location":"sdk/erc1155/PersonalCollection/2_Minting/","text":"const result = await ExpressSDK . erc1155 . collection . mint ( web3 , // Web3 instance configured with metamask provider collectionAddress , // Address of the collection in which item will be minted tokenId , //ID of token tokenAmount , //Amount of token tokenURI , //Token URI String minterAddress , // Address of the owner/minter royalties // Nested Array of Royalties ); After this function is executed, a tokenId will be generated corresponding to the minted item in that particular collection. This id is emitted in an event RoyaltiesSetForTokenId and it can be accessed through: const collectionTokenId = result . events . RoyaltiesSetForTokenId . returnValues . tokenId ;","title":"Mint"},{"location":"sdk/erc1155/PersonalCollection/3_Burning/","text":"const result = await ExpressSDK . erc1155 . collection . burn ( web3 , // Web3 instance configured with metamask provider collectionAddress , // Address of the collection ownerAddress , // Address of token owner tokenId , // Id of token to burn tokenAmount //Amount of token ); Successful execution of this function burns the token associated with the respective token Id inside the collection.","title":"Burn"},{"location":"sdk/erc1155/PersonalCollection/4_Selling/","text":"const result = await ExpressSDK . erc1155 . collection . sellNFT ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain collectionAddress , // Address of the collection tokenId , // TokenId of the item in that collection sellingPrice , // Selling Price of the item ownerAddress , // Address of the collection owner/minter tokenAmount //Amount of token ); After this function is executed the seller of the collection will be able to put up an item on sale from its collection and an event TokenMetaReturn is emitted which contains key-value pairs. const tokenMetaEvent = result . events . TokenMetaReturn . returnValues . data ; tokenMetaEvent variable is an object with following key-value pair: { bidEndTime: \"0\"; // Ending time of bid if item on auction bidSale: false; // Item on auction sale or not bidStartTime: \"0\"; // staring time of bid if item on auction collectionAddress: \"0x9095Ee504caeADfdA6EA81Ee8EC625a5827a6BF2\"; // collection address currentOwner: \"0xbEc53EBdf7833B9d8747522287d5781d265A3e87\"; // current owner address directSale: true; // item on direct sale or not mintedBy: \"0x675056CeEBE35C6c6aB46d7a099CAfEADe153De1\"; // minter address price: \"1000\"; // selling or initial bidding price of item saleId: \"8\"; // sale id of item status: true; // status of item tokenId: \"11\"; // token id of item tokenAmount: \"10\" // amount of token }","title":"Sell"},{"location":"sdk/erc1155/PersonalCollection/6_Buying/","text":"const result = await ExpressSDK . erc721 . collection . buyNFT ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain saleId , // Sale Id of the item buyerAddress , // Address of the buyer buyPrice , // Price at which item is bought tokenAmount //Amount of token ); After the successful execution of this function, token ownership and price money is transferred between the new owner and previous owner respectively","title":"Buy"},{"location":"sdk/erc1155/PersonalCollection/7_Auctioning/","text":"const result = await ExpressSDK . erc1155 . collection . sellNFTByBid ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain collectionAddress , // Address of the collection tokenId , // Token Id of the item initialPrice , // Initial Price to be set for an item ownerAddress , // Address of the item owner tokenAmount //Amount of token ); It emits the same event emitted by sellNFT function i.e. TokenMetaReturn which can be accessed through const tokenMetaEvent = result . events . TokenMetaReturn . returnValues . data ; Items on auction sale can be bid by others using saleId which can be retrieved through tokenMetaEvent .","title":"Auction"},{"location":"sdk/erc1155/PersonalCollection/8_Bidding/","text":"const result = await ExpressSDK . erc721 . collection . bid ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain collectionItemSaleId , // Sale Id of the item on auction bidderAddress , // Address of bidder/buyer bidPrice , // Bid Price placed on item tokenAmount //Amount of token ); An event is emitted in this function call: BidOrderReturn : It can be retrieved from the returned transaction receipt. const bidOrderReturn = result . events . BidOrderReturn . returnValues . bid ; bidOrderReturn variable is an object with following key-value pairs: { buyerAddress: \"0x3A0b38AAC59429e628f3064bb0332061d0602883\"; //Address of the buyer price: \"60000\"; // Buyer's bid on the item saleId: \"97\"; // Sale Id of the item sellerAddress: \"0xe18B1dFb94BB3CEC3B47663F997D824D9cD0f4D2\"; // Address of seller withdrawn: false; // Current status of the bid tokenAmount: \"10\" //Amount of token }","title":"Bid"},{"location":"sdk/erc1155/PersonalCollection/9_ExecutingBid/","text":"const result = await ExpressSDK . erc1155 . collection . acceptBid ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain SaleId , // Sale Id of the token BidId , // Bid Id of the buyer the seller wants to accept sellerAddress // Address of the seller ); When the seller executes/accepts a bid before the auction\u2019s end then a new event is emitted BidExecuted which can be retrieved through the following. const bidExecutedReturnValue = result . events . BidExecuted . returnValues . price ; bidExecutedReturnValue will give the amount at which the bid was accepted.","title":"Execute"},{"location":"sdk/erc1155/PublicCollection/10_CancellingSale/","text":"const result = await ExpressSDK . erc721 . order . cancelSale ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain sellerAddress , // Address of the seller saleId // Sale Id of the item ); After the successful execution of this function, an Item that was on direct sale or auction sale will be removed from sale","title":"Cancel Sale"},{"location":"sdk/erc1155/PublicCollection/1_PNDC/","text":"Tokens can be minted and traded either through the pandora's public collection or a user can create a personal collection and mint and trade NFTs inside it. This section describes the functions for minting and trading through pandora's public contract(collection).","title":"Overview"},{"location":"sdk/erc1155/PublicCollection/2_Minting/","text":"const result = await ExpressSDK . erc1155 . nft . mint ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain minterAddress , // Address of Minter tokenAmount , //Amount of token tokenURI , // TokenURI String royalties // Nested array of royalties ); royalties for a token is of the form: [ [recipientAddress1, royaltyFraction1], [recipientAddress2, royaltyFraction2], . . [recipientAddressN, royaltyFractionN] ] Note: N can be atmost 10 It returns the receipt of the on-chain transaction. Information from Emitted Events can be retrieved by looking at the transaction receipt. Two events are emitted in this function call: -> TransferSingle : It can be retrieved from the returned transaction receipt. const transferEvent = result . events . TransferSingle . returnValues ; transferEvent variable is an object with following key-value pair: { operator: \"0x0000000000000000000000000000000000000000\", //zero address from: \"0x0000000000000000000000000000000000000000\", // zero address to: \"0xbEc53EBdf7833B9d8747522287d5781d265A3e87\", // minter address tokenId: \"11\" // token id of minted token, value: 5, //token Amount } -> RoyaltiesSetForTokenId : It can also be retrieved in a similar manner const royaltiesEvent = result . events . RoyaltiesSetForTokenId . returnValues ; royaltiesEvent variable is an object with following key-value pair: { royalties: [[\"0xbEc53EBdf7833B9d8747522287d5781d265A3e87\", \"100\"]] // array of royalties tokenId: \"11\" // token id of minted token } Token Minted on a specific network can be put on Sale or Auction further on the same Network.","title":"Mint"},{"location":"sdk/erc1155/PublicCollection/3_Burning/","text":"const result = await ExpressSDK . erc1155 . nft . burn ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain ownerAddress , // Address of token owner tokenId // Id of token to burn tokenAmount //Amount of token to burn ); Successful execution of this function will burn token associated to respective tokenId.","title":"Burn"},{"location":"sdk/erc1155/PublicCollection/4_Selling/","text":"const result = await ExpressSDK . erc1155 . order . sellNFT ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain tokenId , // Token Id of NFT tokenPrice , // Selling Price of NFT ownerAddress , // Address of current owner tokenAmount // Amount of token to sell ); An event is emitted in this function call: TokenMetaReturn : It can be retrieved from the returned transaction receipt. const tokenMetaEvent = result . events . TokenMetaReturn . returnValues . data ; tokenMetaEvent variable is an object with following key-value pair: { collectionAddress: \"0x9095Ee504caeADfdA6EA81Ee8EC625a5827a6BF2\"; //Address of Collection tokenId: \"2\"; //ID of token numberOfTokens: \"10\"; //Amount of token to mint price: \"100\"; //Base Selling price directSale: true; //Direct sale or not bidSale: false; //Bid Sale or not status: true; //Status of token currentOwner: \"0xbEc53EBdf7833B9d8747522287d5781d265A3e87\"; //Current owner of token }","title":"Sell"},{"location":"sdk/erc1155/PublicCollection/5_Buying/","text":"const result = await ExpressSDK . erc1155 . order . buyNFT ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain saleId , // Sale Id of NFT buyerAddress , // Address of buyer price // Price of item amount //Amount of token ); After the successful execution of this function, token ownership and price money are transferred between the new owner and previous owner respectively.","title":"Buy"},{"location":"sdk/erc1155/PublicCollection/6_Auctioning/","text":"const result = await ExpressSDK . erc1155 . order . sellNFTByBid ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain tokenId , // Token Id of NFT initialPrice , // Initial Bidding Price of NFT ownerAddress , // Address of current owner amount // Amount of Token ); It emits the same event emitted by sellNFT function i.e. TokenMetaReturn. Items on auction sale can be bid by others using saleId.","title":"Auction"},{"location":"sdk/erc1155/PublicCollection/7_Bidding/","text":"const result = await ExpressSDK . erc1155 . order . bid ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain saleId , // Sale Id of NFT buyerAddress , // Address of bidder/buyer bidPrice // Bid Price placed on item amount // Amount of token ); An event is emitted in this function call: BidOrderReturn : It can be retrieved from the returned transaction receipt. const bidOrderReturn = result . events . BidOrderReturn . returnValues . bid ; bidOrderReturn variable is an object with following key-value pairs: { saleId: \"97\"; // Sale Id of the item tokenAmount: \"10\" //Amount of token sellerAddress: \"0xe18B1dFb94BB3CEC3B47663F997D824D9cD0f4D2\"; // Address of seller buyerAddress: \"0x3A0b38AAC59429e628f3064bb0332061d0602883\"; //Address of the buyer price: \"60000\"; // Buyer's bid on the item withdrawn: false; // Current status of the bid }","title":"Bid"},{"location":"sdk/erc1155/PublicCollection/8_ExcecutingBid/","text":"const result = await ExpressSDK . erc1155 . order . acceptBid ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain SaleId , // Sale Id of the token BidId , // Bid Id of the buyer the seller wants to accept sellerAddress , // Address of the seller ); When the seller executes/accepts a bid before the auction\u2019s end then a new event is emitted BidExecuted which can be retrieved through the following. const bidExecutedReturnValue = result . events . BidExecuted . returnValues . price ; bidExecutedReturnValue will give the amount at which the bid was accepted.","title":"Execute Bid"},{"location":"sdk/erc1155/PublicCollection/9_WithdrawingBid/","text":"const result = await ExpressSDK . erc1155 . order . withdrawBid ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain saleId , // Sale Id of the item on auction bidId , //Bid Id of the buyer in an auction buyerAddress // Address of the bidder ); When the bidder wants to withdraw their bid, they can do so using this function. After successful execution of the function bid will be removed from the auction and the money will be transferred back to the bidder.","title":"Withdraw Bid"},{"location":"sdk/erc721/PersonalCollection/10_WithdrawingBid/","text":"const result = await ExpressSDK . erc721 . collection . withdrawBid ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain saleId , // Sale Id of the item on auction bidId , //Bid Id of the buyer in an auction buyerAddress // Address of the bidder ); When the bidder wants to withdraw their bid, they can do so using this function. After successful execution of the function bid will be removed from the auction and the money will be transferred back to the bidder.","title":"Withdraw"},{"location":"sdk/erc721/PersonalCollection/11_CancellingSale/","text":"const result = await ExpressSDK . erc721 . collection . cancelSale ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain sellerAddress , // Address of the seller saleId // Sale Id of the item ); After the successful execution of this function, the item that was on direct sale or auction sale will be removed from sale.","title":"Cancel Sale"},{"location":"sdk/erc721/PersonalCollection/1_PersonalCollection/","text":"A personal collection can be deployed using SDK and inside a collection, user can furthur mint and trade tokens. const result = await ExpressSDK . erc721 . collection . createCollection ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain ownerAddress , // Address of the collection creator name , // Name of the collection symbol , // Symbol of the collection description , // Description of the collection collectionRoyalties // Royalties received by the owner ); When this function is executed an event is emitted ERC721Deployed which contains the address of the collection. const collectionContractAddress = result . events . ERC721Deployed . returnValues . _tokenAddress ; This variable will contain the required contract address of the collection.","title":"Create Collection"},{"location":"sdk/erc721/PersonalCollection/2_Minting/","text":"const result = await ExpressSDK . erc721 . collection . mint ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain collectionAddress , // Address of the collection in which item will be minted tokenURI , //Token URI String minterAddress , // Address of the owner/minter royalties // Nested Array of Royalties ); After this function is executed, a tokenId will be generated corresponding to the minted item in that particular collection. This id is emitted in an event RoyaltiesSetForTokenId and it can be accessed through: const collectionTokenId = result . events . RoyaltiesSetForTokenId . returnValues . tokenId ;","title":"Mint"},{"location":"sdk/erc721/PersonalCollection/3_BatchMinting/","text":"const result = await ExpressSDK . erc721 . collection . batchMint ( web3 , // Web3 instance configured with metamask provider collectionAddress , // Address of the collection minterAddress , // Address of Minter totalNFT , // Number of tokens to mint arraytokenURI , // array of TokenURI String for each token royalties // array of royalties for each token ); The token Ids for minted tokens can be retrieved through the respective emitted events. (Transfer and RoyaltiesSetForTokenId events are emitted for each token minted through batchMint.)","title":"BatchMint"},{"location":"sdk/erc721/PersonalCollection/4_Burning/","text":"const result = await ExpressSDK . erc721 . collection . burn ( web3 , // Web3 instance configured with metamask provider collectionAddress , // Address of the collection ownerAddress , // Address of token owner tokenId // Id of token to burn ); Successful execution of this function burns the token associated with the respective token Id inside the collection.","title":"Burn"},{"location":"sdk/erc721/PersonalCollection/5_Selling/","text":"const result = await ExpressSDK . erc721 . collection . sellNFT ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain collectionAddress , // Address of the collection tokenId , // TokenId of the item in that collection sellingPrice , // Selling Price of the item ownerAddress // Address of the collection owner/minter ); After this function is executed the seller of the collection will be able to put up an item on sale from its collection and an event TokenMetaReturn is emitted which contains key-value pairs. const tokenMetaEvent = result . events . TokenMetaReturn . returnValues . data ; tokenMetaEvent variable is an object with following key-value pair: { bidEndTime: \"0\"; // Ending time of bid if item on auction bidSale: false; // Item on auction sale or not bidStartTime: \"0\"; // staring time of bid if item on auction collectionAddress: \"0x9095Ee504caeADfdA6EA81Ee8EC625a5827a6BF2\"; // collection address currentOwner: \"0xbEc53EBdf7833B9d8747522287d5781d265A3e87\"; // current owner address directSale: true; // item on direct sale or not mintedBy: \"0x675056CeEBE35C6c6aB46d7a099CAfEADe153De1\"; // minter address price: \"1000\"; // selling or initial bidding price of item saleId: \"8\"; // sale id of item status: true; // status of item tokenId: \"11\"; // token id of item }","title":"Sell"},{"location":"sdk/erc721/PersonalCollection/6_Buying/","text":"const result = await ExpressSDK . erc721 . collection . buyNFT ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain saleId , // Sale Id of the item buyerAddress , // Address of the buyer buyPrice // Price at which item is bought ); After the successful execution of this function, token ownership and price money is transferred between the new owner and previous owner respectively","title":"Buy"},{"location":"sdk/erc721/PersonalCollection/7_Auctioning/","text":"const result = await ExpressSDK . erc721 . collection . sellNFTByBid ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain collectionAddress , // Address of the collection tokenId , // Token Id of the item initialPrice , // Initial Price to be set for an item ownerAddress , // Address of the item owner auctionTime // Auction Time Period in seconds, i.e 120 is equal to 120s. ); It emits the same event emitted by sellNFT function i.e. TokenMetaReturn which can be accessed through const tokenMetaEvent = result . events . TokenMetaReturn . returnValues . data ; Items on auction sale can be bid by others using saleId which can be retrieved through tokenMetaEvent .","title":"Auction"},{"location":"sdk/erc721/PersonalCollection/8_Bidding/","text":"const result = await ExpressSDK . erc721 . collection . bid ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain collectionItemSaleId , // Sale Id of the item on auction bidderAddress , // Address of bidder/buyer bidPrice // Bid Price placed on item ); An event is emitted in this function call: BidOrderReturn : It can be retrieved from the returned transaction receipt. const bidOrderReturn = result . events . BidOrderReturn . returnValues . bid ; bidOrderReturn variable is an object with following key-value pairs: { buyerAddress: \"0x3A0b38AAC59429e628f3064bb0332061d0602883\"; //Address of the buyer price: \"60000\"; // Buyer's bid on the item saleId: \"97\"; // Sale Id of the item sellerAddress: \"0xe18B1dFb94BB3CEC3B47663F997D824D9cD0f4D2\"; // Address of seller withdrawn: false; // Current status of the bid }","title":"Bid"},{"location":"sdk/erc721/PersonalCollection/9_ExecutingBid/","text":"const result = await ExpressSDK . erc721 . collection . acceptBid ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain SaleId , // Sale Id of the token BidId , // Bid Id of the buyer the seller wants to accept sellerAddress // Address of the seller ); When the seller executes/accepts a bid before the auction\u2019s end then a new event is emitted BidExecuted which can be retrieved through the following. const bidExecutedReturnValue = result . events . BidExecuted . returnValues . price ; bidExecutedReturnValue will give the amount at which the bid was accepted.","title":"Execute"},{"location":"sdk/erc721/PublicCollection/10_WithdrawBid/","text":"const result = await ExpressSDK . erc721 . order . withdrawBid ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain saleId , // Sale Id of the item on auction bidId , //Bid Id of the buyer in an auction buyerAddress // Address of the bidder ); When the bidder wants to withdraw their bid, they can do so using this function. After successful execution of the function bid will be removed from the auction and the money will be transferred back to the bidder.","title":"Withdraw Bid"},{"location":"sdk/erc721/PublicCollection/11_CancellingSale/","text":"const result = await ExpressSDK . erc721 . order . cancelSale ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain sellerAddress , // Address of the seller saleId // Sale Id of the item ); After the successful execution of this function, an Item that was on direct sale or auction sale will be removed from sale","title":"Cancel Sale"},{"location":"sdk/erc721/PublicCollection/1_PNDC/","text":"Tokens can be minted and traded either through the pandora's public collection or a user can create a personal collection and mint and trade NFTs inside it. This section describes the functions for minting and trading through pandora's public contract(collection).","title":"Overview"},{"location":"sdk/erc721/PublicCollection/2_Minting/","text":"const result = await ExpressSDK . erc721 . nft . mint ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain minterAddress , // Address of Minter tokenURI , // TokenURI String royalties // Nested array of royalties ); royalties for a token is of the form: [ [recipientAddress1, royaltyFraction1], [recipientAddress2, royaltyFraction2], . . [recipientAddressN, royaltyFractionN] ] Note: N can be atmost 10 It returns the receipt of the on-chain transaction. Information from Emitted Events can be retrieved by looking at the transaction receipt. Two events are emitted in this function call: -> Transfer : It can be retrieved from the returned transaction receipt. const transferEvent = result . events . Transfer . returnValues ; transferEvent variable is an object with following key-value pair: { from: \"0x0000000000000000000000000000000000000000\", // zero address to: \"0xbEc53EBdf7833B9d8747522287d5781d265A3e87\", // minter address tokenId: \"11\" // token id of minted token } -> RoyaltiesSetForTokenId : It can also be retrieved in a similar manner const royaltiesEvent = result . events . RoyaltiesSetForTokenId . returnValues ; royaltiesEvent variable is an object with following key-value pair: { royalties: [[\"0xbEc53EBdf7833B9d8747522287d5781d265A3e87\", \"100\"]] // array of royalties tokenId: \"11\" // token id of minted token } Token Minted on a specific network can be put on Sale or Auction further on the same Network.","title":"Mint"},{"location":"sdk/erc721/PublicCollection/3_BatchMinting/","text":"const result = await ExpressSDK . erc721 . nft . batchMint ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain minterAddress , // Address of Minter totalNFT , // Number of tokens to mint arraytokenURI , // array of TokenURI String for each token royalties // array of royalties for each token ); royalties are of the form: [ royaltyArrayForToken1, royaltyArrayForToken2, . . royaltyArrayForTokenN ] It emits the same events as by Mint for all N tokens where N is the total number of tokens minted through batchMint .","title":"BatchMint"},{"location":"sdk/erc721/PublicCollection/4_Burning/","text":"const result = await ExpressSDK . erc721 . nft . burn ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain ownerAddress , // Address of token owner tokenId // Id of token to burn ); Successful execution of this function will burn token associated to respective tokenId.","title":"Burn"},{"location":"sdk/erc721/PublicCollection/5_Selling/","text":"const result = await ExpressSDK . erc721 . order . sellNFT ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain tokenId , // Token Id of NFT tokenPrice , // Selling Price of NFT ownerAddress // Address of current owner ); An event is emitted in this function call: TokenMetaReturn : It can be retrieved from the returned transaction receipt. const tokenMetaEvent = result . events . TokenMetaReturn . returnValues . data ; tokenMetaEvent variable is an object with following key-value pair: { bidEndTime: \"0\"; // Ending time of bid if item on auction bidSale: false; // Item on auction sale or not bidStartTime: \"0\"; // staring time of bid if item on auction collectionAddress: \"0x9095Ee504caeADfdA6EA81Ee8EC625a5827a6BF2\"; // collection address currentOwner: \"0xbEc53EBdf7833B9d8747522287d5781d265A3e87\"; // current owner address directSale: true; // item on direct sale or not mintedBy: \"0x675056CeEBE35C6c6aB46d7a099CAfEADe153De1\"; // minter address price: \"1000\"; // selling or initial bidding price of item saleId: \"8\"; // sale id of item status: true; // status of item tokenId: \"11\"; // token id of item }","title":"Sell"},{"location":"sdk/erc721/PublicCollection/6_Buying/","text":"const result = await ExpressSDK . erc721 . order . buyNFT ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain saleId , // Sale Id of NFT buyerAddress , // Address of buyer price // Price of item ); After the successful execution of this function, token ownership and price money are transferred between the new owner and previous owner respectively.","title":"Buy"},{"location":"sdk/erc721/PublicCollection/7_Auctioning/","text":"const result = await ExpressSDK . erc721 . order . sellNFTByBid ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain tokenId , // Token Id of NFT initialPrice , // Initial Bidding Price of NFT ownerAddress , // Address of current owner auctionTime // Auction Time Period in seconds ); It emits the same event emitted by sellNFT function i.e. TokenMetaReturn. Items on auction sale can be bid by others using saleId.","title":"Auction"},{"location":"sdk/erc721/PublicCollection/8_Bidding/","text":"const result = await ExpressSDK . erc721 . order . bid ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain saleId , // Sale Id of NFT buyerAddress , // Address of bidder/buyer bidPrice // Bid Price placed on item ); An event is emitted in this function call: BidOrderReturn : It can be retrieved from the returned transaction receipt. const bidOrderReturn = result . events . BidOrderReturn . returnValues . bid ; bidOrderReturn variable is an object with following key-value pairs: { buyerAddress: \"0x3A0b38AAC59429e628f3064bb0332061d0602883\"; //Address of the buyer price: \"60000\"; // Buyer's bid on the item saleId: \"97\"; // Sale Id of the item sellerAddress: \"0xe18B1dFb94BB3CEC3B47663F997D824D9cD0f4D2\"; // Address of seller withdrawn: false; // Current status of the bid }","title":"Bid"},{"location":"sdk/erc721/PublicCollection/9_ExecutingBid/","text":"const result = await ExpressSDK . erc721 . order . acceptBid ( web3 , // Web3 instance configured with metamask provider chainId , // Network id of blockchain SaleId , // Sale Id of the token BidId , // Bid Id of the buyer the seller wants to accept sellerAddress // Address of the seller ); When the seller executes/accepts a bid before the auction\u2019s end then a new event is emitted BidExecuted which can be retrieved through the following. const bidExecutedReturnValue = result . events . BidExecuted . returnValues . price ; bidExecutedReturnValue will give the amount at which the bid was accepted.","title":"Execute Bid"},{"location":"sdk/pinata/1_UploadingToPinata/","text":"Upload NFTs to Pinata Cloud Service: const result = await PandoraSDK . pinata . upload ( nftImageFile , //File to be uploaded to Pinata nftDescription , // Description of the NFT pinataApiKey , // Pinata API Key pinataSecretApiKey // Pinata Secret API Key ); After uploading the NFT Image successfully, we can get the IPFS link of the image from the response by getting the IPFS Hash. const hash = result . data . IpfsHash ; And appending that hash to the following link \"<https://gateway.pinata.cloud/ipfs/{hash}>\" Upload JSON data to Pinata Cloud Service: const result = await PandoraSDK . pinata . pinJSON ( pinataAPIKeyJSON , // Pinata API Key pinataSecretApiKeyJSON , // Pinata Secret API Key pinataJSONData // JSON data to upload );","title":"Pinata"},{"location":"sdk/pinata/1_UploadingToPinata/#upload-nfts-to-pinata-cloud-service","text":"const result = await PandoraSDK . pinata . upload ( nftImageFile , //File to be uploaded to Pinata nftDescription , // Description of the NFT pinataApiKey , // Pinata API Key pinataSecretApiKey // Pinata Secret API Key ); After uploading the NFT Image successfully, we can get the IPFS link of the image from the response by getting the IPFS Hash. const hash = result . data . IpfsHash ; And appending that hash to the following link \"<https://gateway.pinata.cloud/ipfs/{hash}>\"","title":"Upload NFTs to Pinata Cloud Service:"},{"location":"sdk/pinata/1_UploadingToPinata/#upload-json-data-to-pinata-cloud-service","text":"const result = await PandoraSDK . pinata . pinJSON ( pinataAPIKeyJSON , // Pinata API Key pinataSecretApiKeyJSON , // Pinata Secret API Key pinataJSONData // JSON data to upload );","title":"Upload JSON data to Pinata Cloud Service:"},{"location":"smart-conrtracts/1_ContractsDeployment/","text":"Procedure to deploy contracts on local as well as public blockchains. \u2192Clone the Repository Modular-Contract \u2192Install the dependencies by running - npm install For deployment on the local network: \u2192Start truffle development console by running following command in terminal - truffle develop \u2192For compiling and deploying on the local blockchain, run - compile --all migrate --reset For deployment on the public test network: \u2192Create a \u2018.env\u2019 file in the root directory and add a private key : PK = <PRIVATE_KEY> INFURA_API = <YOUR INFURA API> BSC_API = <BINANCE API> \u2192For compiling and deploying on the public test blockchain, run - truffle compile --all truffle migrate --reset --network testnet","title":"Contract deployment"},{"location":"smart-conrtracts/1_ContractsDeployment/#procedure-to-deploy-contracts-on-local-as-well-as-public-blockchains","text":"\u2192Clone the Repository Modular-Contract \u2192Install the dependencies by running - npm install","title":"Procedure to deploy contracts on local as well as public blockchains."},{"location":"smart-conrtracts/1_ContractsDeployment/#for-deployment-on-the-local-network","text":"\u2192Start truffle development console by running following command in terminal - truffle develop \u2192For compiling and deploying on the local blockchain, run - compile --all migrate --reset","title":"For deployment on the local network:"},{"location":"smart-conrtracts/1_ContractsDeployment/#for-deployment-on-the-public-test-network","text":"\u2192Create a \u2018.env\u2019 file in the root directory and add a private key : PK = <PRIVATE_KEY> INFURA_API = <YOUR INFURA API> BSC_API = <BINANCE API> \u2192For compiling and deploying on the public test blockchain, run - truffle compile --all truffle migrate --reset --network testnet","title":"For deployment on the public test network:"},{"location":"smart-conrtracts/1_Overview/","text":"Pandora Protocol consists of a variety of Smart Contracts and Libraries for minting, buying, selling, auctioning, and bidding tokens of ERC721 and ERC1155 standard. Contracts Overview Tokens can be created either using Pandora\u2019s public contract PNDC_ERC721 / PNDC_ERC1155 or a collection can be deployed using the TokenFactory / TokenFactory1155 contract and then tokens can be created inside that collection. TokenERC721 / TokenERC1155 contract contains boilerplate functions for all the collection contracts that will be deployed. NFTFactoryContract / NFTFactoryContract1155 contains functions for selling and buying tokens. NFTBid / NFTBid1155 contract contains functions for auction sale and bidding. NFTStorage / NFTStorage1155 contract is used as a storage contract for all the sale and collection data. Libraries Overview Libraries are used by Smart Contracts to hold useful data in an organized way. LibShare library contains the royalty share structure. LibMeta / LibMeta1155 library contains the sales metadata structure. LibCollection / LibCollection1155 library contains the collections metadata structure. LibBid / LibBid1155 library contains the bid Order structure. LibERC721 / LibERC1155 library contains a function to deploy a new ERC721 contract(collection).","title":"Overview"},{"location":"smart-conrtracts/1_Overview/#contracts-overview","text":"Tokens can be created either using Pandora\u2019s public contract PNDC_ERC721 / PNDC_ERC1155 or a collection can be deployed using the TokenFactory / TokenFactory1155 contract and then tokens can be created inside that collection. TokenERC721 / TokenERC1155 contract contains boilerplate functions for all the collection contracts that will be deployed. NFTFactoryContract / NFTFactoryContract1155 contains functions for selling and buying tokens. NFTBid / NFTBid1155 contract contains functions for auction sale and bidding. NFTStorage / NFTStorage1155 contract is used as a storage contract for all the sale and collection data.","title":"Contracts Overview"},{"location":"smart-conrtracts/1_Overview/#libraries-overview","text":"Libraries are used by Smart Contracts to hold useful data in an organized way. LibShare library contains the royalty share structure. LibMeta / LibMeta1155 library contains the sales metadata structure. LibCollection / LibCollection1155 library contains the collections metadata structure. LibBid / LibBid1155 library contains the bid Order structure. LibERC721 / LibERC1155 library contains a function to deploy a new ERC721 contract(collection).","title":"Libraries Overview"},{"location":"smart-conrtracts/2_Architecture/","text":"Contracts are built using openzeppelin\u2019s upgradeable smart contracts library. So the smart contract code can be updated to support new features, fix bugs, etc. Functionalities are divided into different parts and some contracts are inherited by other contracts as well as by openzeppelin\u2019s contracts. The TokenFactory contract inherits the NFTBid contract which inherits NFTFactoryContract which again inherits the NFTStorage contract. Similarly in ERC1155 part, The TokenFactory1155 contract inherits the NFTBid1155 contract which inherits NFTFactoryContract115 which again inherits the NFTStorage1155 contract.","title":"Architecture"},{"location":"smart-conrtracts/erc1155/4_Functions/3.10_CancellingSale/","text":"NFTs can be removed from direct sale or auction sale using cancelSale function of NFTFactoryContract1155 contract. cancelSale ( uint256 _saleId ) _saleId : Id of the item on sale","title":"CancelSale"},{"location":"smart-conrtracts/erc1155/4_Functions/3.11_BidOrderBook/","text":"All the bids are stored in mapping Bids which maps _saleId to an array of BidOrder struct. Each element of the array represents a bid with the last element as recent bid. mapping ( uint256 => LibBid . BidOrder []) public Bids ;","title":"BidOrderBook"},{"location":"smart-conrtracts/erc1155/4_Functions/3.1_Functions/","text":"Pandora Protocol's Smart Contracts have various functionalities like Minting, Selling, Buying, Auctioning tokens as well as creating personal collections and executing these functionalities inside collections. A few major functions for ERC1155 standard are mentioned in the following pages.","title":"Overview"},{"location":"smart-conrtracts/erc1155/4_Functions/3.2_Collections/","text":"Collections can be deployed using the deployERC1155 function of the TokenFactory1155 contract deployERC1155 ( string memory _uri , string memory description , LibShare . Share [] memory royalties ) _uri : Base URI description : Description of the collection royalties : array of Share struct Tokens can be created inside collections and can be sold, bought, and auctioned.","title":"Collection"},{"location":"smart-conrtracts/erc1155/4_Functions/3.3_minting/","text":"Minting is done using Mint function in both (PNDC_ERC1155 and TokenERC1155) contracts. For PNDC_ERC1155 mint ( address account , uint256 amount , bytes memory data , string memory uri , LibShare . Share [] memory royalties ) account : Address of the owner amount : Amount of Token data : Token data uri : Token Uri royalties : array of Share struct For TokenERC1155 mint ( address account , uint256 id , uint256 amount , string memory _uri , bytes memory data ) account : Address of the owner id : ID of token amount : Amount of token _uri : Token Uri royaltiesSet : RoyaltiesSet struct","title":"Mint"},{"location":"smart-conrtracts/erc1155/4_Functions/3.5_Royalties/","text":"Royalties for a token can be retrieved using getRoyalties function in both (PNDC_ERC1155 and TokenERC1155) contracts. getRoyalties ( uint256 _tokenId ) It returns an array of Share struct. In the TokenERC1155 contract, there are additional functions for setting Royalties by token Id and for collections. By TokenId- setRoyaltiesByTokenId ( uint256 _tokenId , RoyaltiesSet memory royaltiesSet ) _tokenId : Id of token whose royalty is getting set royaltiesSet : RoyaltiesSet struct It emits an event: RoyaltiesSetForTokenId ( _tokenId , royaltiesSet . royalties ); For Collections- setRoyaltiesForCollection ( LibShare . Share [] memory royalties ) royalties : array of Share struct It emits an event: RoyaltiesSetForCollection ( royalties );","title":"Royalties"},{"location":"smart-conrtracts/erc1155/4_Functions/3.6_Selling/","text":"Selling of NFTs can be performed using sellNFT function of NFTFactoryContract1155.sol contract. sellNFT ( address _collectionAddress , uint256 _tokenId , uint256 _price , uint256 _amount ) _collectionAddress : address of collection _tokenId : Id of token willing to sell _price : selling price _amount : Amount of Token It emits an event: TokenMetaReturn(meta, _tokenIdTracker.current()) meta : TokenMeta struct _tokenIdTracker.current() : a counter tracking current token Id","title":"Sell"},{"location":"smart-conrtracts/erc1155/4_Functions/3.7_Buying/","text":"NFTs can be bought using buyNFT function of NFTFactoryContract1155.sol contract. BuyNFT ( uint256 _saleId , uint256 _amount ) _saleId : Id of the item on sale _amount : Amount of Token.","title":"Buy"},{"location":"smart-conrtracts/erc1155/4_Functions/3.8_Auctioning/","text":"NFTs can also be put on Auction Sale using sellNFT_byBid function of NFTBid1155 contract. An auction sale is the sale of goods through a bidding process. SellNFT_byBid ( address _collectionAddress , uint256 _tokenId , uint256 _price , uint256 _amount ) _collectionAddress : address of collection _tokenId : Id of token willing to sell _price : selling price _amount : Amount of Tokens It emits an event: TokenMetaReturn ( meta , _tokenIdTracker . current ()) meta : TokenMeta struct _tokenIdTracker.current() : a counter tracking current token Id","title":"Auction"},{"location":"smart-conrtracts/erc1155/4_Functions/3.9_Bidding/","text":"Anyone can bid on NFT on auction sale using bid function of NFTBid1155 contract. Bid ( uint256 _saleId , uint256 _amount ) _saleId : Id of the item on auction sale _amount : Amount of Tokens It emits an event: BidOrderReturn ( bid ); bid : BidOrder struct Executing Bid A bid can be executed by the owner of NFT using executeBidOrder function of NFTBid1155 contract. executeBidOrder ( uint256 _saleId , uint256 _bidOrderID ) _saleId : Id of the item on auction sale _bidOrderId : Id of bid order It emits an event: BidExecuted(Bids[_saleId][_bidOrderID].price) Bids[_saleId][_bidorderid].price : price at which bid executed Withdrawing Bid Other bidders can withdraw their money using withdrawBidMoney function of NFTBid contract. withdrawBidMoney ( uint256 _saleId , uint256 _bidId ) _saleId : Id of the item that was on auction sale _bidId : Id of that bid","title":"Bid"},{"location":"smart-conrtracts/erc1155/4_Functions/3.9_Bidding/#executing-bid","text":"A bid can be executed by the owner of NFT using executeBidOrder function of NFTBid1155 contract. executeBidOrder ( uint256 _saleId , uint256 _bidOrderID ) _saleId : Id of the item on auction sale _bidOrderId : Id of bid order It emits an event: BidExecuted(Bids[_saleId][_bidOrderID].price) Bids[_saleId][_bidorderid].price : price at which bid executed","title":"Executing Bid"},{"location":"smart-conrtracts/erc1155/4_Functions/3.9_Bidding/#withdrawing-bid","text":"Other bidders can withdraw their money using withdrawBidMoney function of NFTBid contract. withdrawBidMoney ( uint256 _saleId , uint256 _bidId ) _saleId : Id of the item that was on auction sale _bidId : Id of that bid","title":"Withdrawing Bid"},{"location":"smart-conrtracts/erc1155/4_Functions/Burn/","text":"Minted NFTs can be burned by the owner using burn function of both PNDC_ERC1155 and TokenERC1155 contract. burn ( uint256 _id , uint256 _amount ) _id : ID of Token _amount : Amount of Token to burn","title":"Burn"},{"location":"smart-conrtracts/erc1155/Structs/1_Structs/","text":"Structs are special data types in solidity which hold data of different types. There are many structs used in the Smart Contracts which are covered in this section.","title":"Overview"},{"location":"smart-conrtracts/erc1155/Structs/2_RoyalitiesSet/","text":"struct RoyaltiesSet { bool set ; LibShare . Share [] royalties ; } \u2192set : boolean value \u2192royalties : array of Share struct","title":"RoyaltiesSet"},{"location":"smart-conrtracts/erc1155/Structs/3_TokenMeta/","text":"struct TokenMeta { address collectionAddress ; uint256 tokenId ; uint256 numberOfTokens ; uint256 price ; bool directSale ; bool bidSale ; bool status ; address currentOwner ; } \u2192collectionAddress : collection address \u2192tokenId : Id of token \u2192numberOfTokens : Amount of tokens \u2192price : selling price/base bidding price \u2192directSale : item on direct sale or not \u2192bidSale : item on bid sale or not \u2192status : status of item \u2192currentOwner : address of current owner","title":"TokenMeta"},{"location":"smart-conrtracts/erc1155/Structs/4_BidOrder/","text":"struct BidOrder { uint256 saleId ; uint256 numberOfTokens ; address sellerAddress ; address buyerAddress ; uint256 price ; bool withdrawn ; } \u2192saleId : Id of item on sale \u2192numberOfTokens : Amount of Tokens \u2192sellerAddress : address of the current owner \u2192buyerAddress : address of the current bidder \u2192price : current bid price \u2192withdrawn : bid value is withdrawn or not","title":"BidOrder"},{"location":"smart-conrtracts/erc1155/Structs/Share/","text":"struct Share { address payable account ; uint96 value ; } \u2192account : address of royalty receiver \u2192value : the amount of royalty","title":"Share"},{"location":"smart-conrtracts/erc721/3_Functions/3.10_CancellingSale/","text":"NFTs can be removed from direct sale or auction sale using cancelSale function of NFTFactoryContract contract. cancelSale ( uint256 _saleId ) _saleId : Id of the item on sale","title":"CancelSale"},{"location":"smart-conrtracts/erc721/3_Functions/3.11_BidOrderBook/","text":"All the bids are stored in mapping Bids which maps _saleId to an array of BidOrder struct. Each element of the array represents a bid with the last element as recent bid. mapping ( uint256 => LibBid . BidOrder []) public Bids ;","title":"BidOrderBook"},{"location":"smart-conrtracts/erc721/3_Functions/3.1_Functions/","text":"Pandora Protocol's Smart Contracts have various functionalities like Minting, Selling, Buying, Auctioning tokens as well as creating personal collections and executing these functionalities inside collections. A few major functions for ERC721 standard are mentioned in the following pages.","title":"Overview"},{"location":"smart-conrtracts/erc721/3_Functions/3.2_Collections/","text":"Collections can be deployed using the deployERC721 function of the TokenFactory contract deployERC721 ( string memory name , string memory symbol , string memory description , LibShare . Share [] memory royalties ) name : Name of the collection symbol : Symbol of the collection description : Description of the collection royalties : array of Share struct Tokens can be created inside collections and can be sold, bought, and auctioned.","title":"Collection"},{"location":"smart-conrtracts/erc721/3_Functions/3.3_Minting/","text":"Minting is done using safeMint function in both (PNDC_ERC721 and TokenERC721) contracts. For PNDC_ERC721 safeMint ( address to , string memory uri , LibShare . Share [] memory royalties ) to : address of the owner uri : suffix for the token uri royalties : array of Share struct For TokenERC721 safeMint ( address to , string memory uri , RoyaltiesSet memory royaltiesSet ) to : address of the owner uri : suffix for the token uri royaltiesSet : RoyaltiesSet struct","title":"Mint"},{"location":"smart-conrtracts/erc721/3_Functions/3.4_BatchMinting/","text":"Batch Minting is performed using batchMint function For PNDC_ERC721 batchMint ( uint256 _totalNft , string [] memory _uri , LibShare . Share [][] memory royaltiesSet ) _totalNFT : number of NFTs to mint _uri : array of uri royaltiesSet : nested array of Share struct For TokenERC721 batchMint ( uint256 _totalNft , string [] memory _uri , RoyaltiesSet memory royaltiesSet ) _totalNFT : number of NFTs to mint _uri : array of uri royaltiesSet : RoyaltiesSet struct","title":"BatchMint"},{"location":"smart-conrtracts/erc721/3_Functions/3.5_Royalties/","text":"Royalties for a token can be retrieved using getRoyalties function in both (PNDC_ERC721 and TokenERC721) contracts. getRoyalties ( uint256 _tokenId ) It returns an array of Share struct. In the TokenERC721 contract, there are additional functions for setting Royalties by token Id and for collections. By TokenId- setRoyaltiesByTokenId ( uint256 _tokenId , RoyaltiesSet memory royaltiesSet ) _tokenId : Id of token whose royalty is getting set royaltiesSet : RoyaltiesSet struct It emits an event: RoyaltiesSetForTokenId ( _tokenId , royaltiesSet . royalties ); For Collections- setRoyaltiesForCollection ( LibShare . Share [] memory royalties ) royalties : array of Share struct It emits an event: RoyaltiesSetForCollection ( royalties );","title":"Royalties"},{"location":"smart-conrtracts/erc721/3_Functions/3.6_Selling/","text":"Selling of NFTs can be performed using sellNFT function of NFTFactoryContract contract. sellNFT ( address _collectionAddress , uint256 _tokenId , uint256 _price ) _collectionAddress : address of collection _tokenId : Id of token willing to sell _price : selling price It emits an event: TokenMetaReturn(meta, _tokenIdTracker.current()) meta : TokenMeta struct _tokenIdTracker.current() : a counter tracking current token Id","title":"Sell"},{"location":"smart-conrtracts/erc721/3_Functions/3.7_Buying/","text":"NFTs can be bought using buyNFT function of NFTFactoryContract contract. BuyNFT ( uint256 _saleId ) _saleId : Id of the item on sale","title":"Buy"},{"location":"smart-conrtracts/erc721/3_Functions/3.8_Auctioning/","text":"NFTs can also be put on Auction Sale using sellNFT_byBid function of NFTBid contract. An auction sale is the sale of goods through a bidding process. SellNFT_byBid ( address _collectionAddress , uint256 _tokenId , uint256 _price , uint256 _bidTime ) _collectionAddress : address of collection _tokenId : Id of token willing to sell _price : selling price _bidTime : time till NFT is on auction It emits an event: TokenMetaReturn ( meta , _tokenIdTracker . current ()) meta : TokenMeta struct _tokenIdTracker.current() : a counter tracking current token Id","title":"Auction"},{"location":"smart-conrtracts/erc721/3_Functions/3.9_Bidding/","text":"Anyone can bid on NFT on auction sale using bid function of NFTBid contract. Bid ( uint256 _saleId ) _saleId : Id of the item on auction sale It emits an event: BidOrderReturn ( bid ); bid : BidOrder struct Executing Bid A bid can be executed by the owner of NFT using executeBidOrder function of NFTBid contract. executeBidOrder ( uint256 _saleId , uint256 _bidOrderID ) _saleId : Id of the item on auction sale _bidOrderId : Id of bid order It emits an event: BidExecuted(Bids[_saleId][_bidOrderID].price) Bids[_saleId][_bidorderid].price : price at which bid executed Withdrawing Bid Other bidders can withdraw their money using withdrawBidMoney function of NFTBid contract. withdrawBidMoney ( uint256 _saleId , uint256 _bidId ) _saleId : Id of the item that was on auction sale _bidId : Id of that bid","title":"Bid"},{"location":"smart-conrtracts/erc721/3_Functions/3.9_Bidding/#executing-bid","text":"A bid can be executed by the owner of NFT using executeBidOrder function of NFTBid contract. executeBidOrder ( uint256 _saleId , uint256 _bidOrderID ) _saleId : Id of the item on auction sale _bidOrderId : Id of bid order It emits an event: BidExecuted(Bids[_saleId][_bidOrderID].price) Bids[_saleId][_bidorderid].price : price at which bid executed","title":"Executing Bid"},{"location":"smart-conrtracts/erc721/3_Functions/3.9_Bidding/#withdrawing-bid","text":"Other bidders can withdraw their money using withdrawBidMoney function of NFTBid contract. withdrawBidMoney ( uint256 _saleId , uint256 _bidId ) _saleId : Id of the item that was on auction sale _bidId : Id of that bid","title":"Withdrawing Bid"},{"location":"smart-conrtracts/erc721/3_Functions/Burn/","text":"Minted NFTs can be burned using burn function of both PNDC_ERC721 and TokenERC721 contract. burn ( uint256 _tokenId ) _tokenId : Id of token to burn","title":"Burn"},{"location":"smart-conrtracts/erc721/Structs/1_Structs/","text":"Structs are special data types in solidity which hold data of different types. There are many structs used in the Smart Contracts which are covered in this section.","title":"Overview"},{"location":"smart-conrtracts/erc721/Structs/2_RoyaltiesSet/","text":"struct RoyaltiesSet { bool set ; LibShare . Share [] royalties ; } \u2192set : boolean value \u2192royalties : array of Share struct","title":"RoyaltiesSet"},{"location":"smart-conrtracts/erc721/Structs/3_TokenMeta/","text":"struct TokenMeta { uint256 saleId ; address collectionAddress ; uint256 tokenId ; uint256 price ; bool directSale ; bool bidSale ; bool status ; uint256 bidStartTime ; uint256 bidEndTime ; address currentOwner ; } \u2192saleId : Id of item on sale \u2192collectionAddress : collection address \u2192tokenId : Id of token \u2192price : selling price/base bidding price \u2192directSale : item on direct sale or not \u2192bidSale : item on bid sale or not \u2192status : status of item \u2192bidStartTime : auction start time \u2192bidEndTime : auction end time \u2192currentOwner : address of current owner","title":"TokenMeta"},{"location":"smart-conrtracts/erc721/Structs/4_BidOrder/","text":"struct BidOrder { uint256 bidId ; uint256 saleId ; address sellerAddress ; address buyerAddress ; uint256 price ; bool withdrawn ; } \u2192bidId : bid Id of item \u2192saleId : Id of item on sale \u2192sellerAddress : address of the current owner \u2192buyerAddress : address of the current bidder \u2192price : current bid price \u2192withdrawn : bid value is withdrawn or not","title":"BidOrder"},{"location":"smart-conrtracts/erc721/Structs/Share/","text":"struct Share { address payable account ; uint96 value ; } \u2192account : address of royalty receiver \u2192value : the amount of royalty","title":"Share"}]}